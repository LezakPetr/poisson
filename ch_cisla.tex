\chapter{Čísla}

\begin{prolog}
:- ensure_loaded("../equations/formula").
:- ensure_loaded("../equations/truth_table").

make_test_numbers([-1, 0, 0.5, 1, 2, 3, 1.5]).
make_test_nonzero_numbers([-1, 1, 2, 3, 1.5]).
make_test_positive_numbers([1, 2, 3, 1.5]).
make_test_log_bases([0.5, 2, 3, 1.5]).
make_test_integers([-3, -2, -1, 0, 1, 2, 3]).
make_test_nonzero_integers([-3, -2, -1, 1, 2, 3]).
make_test_natural_numbers([1, 2, 3, 4, 5]).
make_test_predicates(Y, [equal([Y, 1]), equal([Y, 2]), log_true, log_false]).

make_test_nonempty_sets([set(S1), set(S2), set(S3), set(S4)]) :-
	make_set([1], S1),
	make_set([2], S2),
	make_set([1, 2], S3),
	make_set([-1, 0, 1, 2, 3, 1.5], S4).
	
\end{prolog}


\begin{abstract}
V~této kapitole definujeme obory čísel od přirozených po reálná a~prozkoumáme jejich vlastnosti.
\end{abstract}

\section{Přirozená čísla}

Začněme nějjednoduššími tzv. přirozenými čísly. Přirozenými čísly rozumíme čísla 1, 2, 3 atd. Upozorňuji, že literatura není jednotná v~tom, zda je nula přirozené číslo. V~této knize nulu nepovažujeme za přirozené číslo. Přirozená čísla typicky vyjadřují počet nějakých objektů. Množinu všech přirozených čísel značíme \(\naturalnumbers\). Tato množina je nekonečná, neexistuje největší přirozené číslo.

Prozkoumejme, jak můžeme přirozená čísla definovat. Nejnižší přirozené číslo je 1. Každé přirozené číslo \(n\) má
následníka, označme ho \(n + 1\). Každé přirozené číslo, vyjma čísla 1, je následníkem právě jednoho čísla. To nás vede k~axiomům~\eqref{eq:natural_numbers_definition_1} až~\eqref{eq:natural_numbers_definition_4}.

\begin{fact}
\begin{prolog}
?-	print_validated_formula(
		'natural_numbers_definition_1',
		in(1, natural_numbers)
	).
\end{prolog}
\eeq{natural_numbers_definition_1}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_definition_2',
		forall_in(N, 'n', natural_numbers, Values,
				in(N + 1, natural_numbers)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_2}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_definition_3',
		forall_in([M, N], ['m', 'n'], natural_numbers, Values,
			equiv(
					equal([M, N]),
					equal([M + 1, N + 1])
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_3}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_definition_4',
		not(
			exists_in(N, 'n', natural_numbers, Values,
				equal([N + 1, 1])
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_4}
%%%%%%%%%%%%%%%%%%%%%
Pro každý predikát \(\predicate{A}(n)\) platí:
\begin{prolog}
?-	make_test_numbers(Values),
	make_test_predicates(Z, Predicates),
	print_validated_formula(
		'natural_numbers_definition_induction',
		declare_predicate(A, 'A', Predicates,
			impl(			
				and(
					apply(A, [Z], [1]),
					forall_in(N, 'n', natural_numbers, Values,
						impl(
							apply(A, [Z], [N]),
							apply(A, [Z], [N + 1])
						)
					)
				),
				forall_in(N, 'n', natural_numbers, Values,
					apply(A, [Z], [N])
				)
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_induction}
\end{fact}

Číslo 2 tedy můžeme zapsat jako \(1 + 1\), číslo 3 jako \(2 + 1 = (1 + 1) + 1\) atd. Zápis a~význam přirozených čísel nám shrnuje tabulka~\ref{tab:natural_numbers}. Vidíme, že počet jedniček v~zápisu odpovídá počtu reprezentovaných objektů.

\begin{table}[ht]
\centering
\begin{tabular}{|r|l|l|l|}
\hline
Číslo & Pořadí & Reprezentace & Význam \\
\hline
1 & 1 & 1 & \(\bigcirc\) \\
2 & 1 + 1 & 1 + 1 & \(\bigcirc \bigcirc\) \\
3 & 2 + 1 & (1 + 1) + 1 & \(\bigcirc \bigcirc \bigcirc\) \\
4 & 3 + 1 & ((1 + 1) + 1) + 1 & \(\bigcirc \bigcirc \bigcirc \bigcirc\) \\
\ldots & \ldots & \ldots & \ldots \\
\hline
\end{tabular}
\caption{Přirozená čísla}
\label{tab:natural_numbers}
\end{table}

Fakt, že každé přirozené číslo kromě jedničky je následník jiného přirozeného čísla, nám umožňuje zavést důkaz matematickou indukcí. Máme-li predikát \(\predicate{A}(n)\), který je pravdivý pro \(n=1\) a~z~jeho pravdivosti pro \(n\) plyne  pravdivost pro \(n + 1\), pak je tento predikát pravdivý pro všechna přirozená čísla. Důkaz matematickou
indukcí popisuje axiom~\eqref{eq:natural_numbers_definition_induction}.

Intuitivně je princip důkazu matematickou indukcí zřejmý. Víme, že predikát \(\predicate{A}(n)\) je pravdivý pro \(n=1\). Z~jeho pravdivosti pro \(n=1\) plyne pravdivost pro \(n=2\), z~ní pak pro \(n=3\) atd. Jedná se vlastně o~tranzitivitu implikace prodlouženou do nekonečna.

Aximom~\eqref{eq:natural_numbers_definition_induction} má ještě jeden význam. Axiomy~\eqref{eq:natural_numbers_definition_1} až~\eqref{eq:natural_numbers_definition_4} nám definují, že existují přirozená čísla mající strukturu podle tabulky~\ref{tab:natural_numbers}. Nezaručují nám ale, že existují pouze takováto přirozená čísla. To nám zaručuje právě axiom~\eqref{eq:natural_numbers_definition_induction}, stačí zvolit \(\predicate{A}(n) = \) \uv{\(n\) lze vyjádřit postupným přičítáním 1 k~číslu 1}. Tento predikát je pravdivý pro každé přirozené číslo, které odpovídá tabulce ~\ref{tab:natural_numbers}, ale pouze pro ně. Zkuste ho dokázat matematickou indukcí. Z~toho ale vyplývá, že množina přirozených čísel nemůže obsahovat čísla nesplňující tento predikát, protože jinak by axiom~\eqref{eq:natural_numbers_definition_induction} udával, že predikát je pravdivý i~pro tato čísla. Tím bychom získali spor. Souhrně nazýváme axiomy~\eqref{eq:natural_numbers_definition_1} až~\eqref{eq:natural_numbers_definition_induction} Peanovy axiomy.

Přirozená čísla lze také znázornit na číselné ose, jak je zobrazeno na obrázku~\ref{img:ciselna_osa}. Osa začíná číslem 1 a~pokračuje do nekonečna.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{0}{4}	
\end{tikzpicture}
\caption{Číselná osa}
\label{img:ciselna_osa}
\end{figure}

Nyní, když už víme, co jsou přirozená čísla, tak si zkusme definovat jejich součet. Jak se sčítají přirozená čísla všichni víme od~první třídy základní školy. Chceme-li sečíst čísla \(a\) a~\(b\), pak k~číslu \(a\) \(b\)-krát přičteme jedničku:

\begin{equation}
\label{eq:soucet_n_definice}
c = a + b = a + \overbrace{1 + 1 + 1 + ...}^{b \times}
\end{equation}

Povšimněme si, že výraz pod složenou závorkou odpovídá reprezentaci čísla \(b\) až na pořadí přičítání jedniček. Proto pokud bychom tento vztah rozepsali pomocí zavedené reprezentace přirozených čísel, tak by \uv{počet jedniček} v~jednotlivých částech rovnice~\eqref{eq:soucet_n_definice} byl stejný, pouze by byly jinak uzávorkované. Například pro \(a=2\), \(b=3\) bychom dostali:

\begin{prolog}
?-	print_validated_formula(
		'add_example',
		equal(
			[
				2 + 3,
				par(1 + 1) + par(par(1 + 1) + 1),
				linebreak,
				par(par(par(1 + 1) + 1) + 1) + 1,
				5
			]
		)
	).
\end{prolog}
\eeq{add_example}

To je logické, součet má představovat počet objektů, které ze dvou skupin dáme dohromady. Přesunutím objektů do jedné skupiny se tyto objekty nemohou vytvořit nebo ztratit. Každý objekt je reprezentován jednou jedničkou, proto se tyto jedničky mohou pouze přeskupovat, ale jejich počet se nemůže změnit. Se součtem, popřípadě součty, můžeme proto provádět takové operace, které nezmění počet jedniček ve výrazu s~reprezentacemi přirozených čísel. Máme dvě takovéto operace. Můžeme prohodit operandy součtu beze změny jeho hodnoty. Tato vlastnost se nazývá komutativita sčítání a~popisuje ji rovnice~\eqref{eq:natural_numbers_comutativity}. Dále můžeme změnit uzávorkování součtů beze změny celkového součtu. Tato vlastnost se nazývá asociativita sčítání a~popisuje ji rovnice~\eqref{eq:natural_numbers_asociativity}. Tyto dvě vlastnosti nám umožňují nedbát na pořadí sčítání, protože sčítance můžeme libovolně přeskládat. Proto také vůbec nemusíme při sčítání psát závorky.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_comutativity',
		forall_in([A, B], ['a', 'b'], natural_numbers, Values,
			equal([A + B, B + A])
		)
	).
\end{prolog}
\eeq{natural_numbers_comutativity}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_asociativity',
		forall_in([A, B, C], ['a', 'b', 'c'], natural_numbers, Values,
			equal([par(A + B) + C, A + par(B + C)])
		)
	).
\end{prolog}
\eeq{natural_numbers_asociativity}
\end{fact}

Nyní můžeme zapomenout na původní definici součtu pomocí přičítání jedniček. Rovnice~\eqref{eq:natural_numbers_comutativity} a~\eqref{eq:natural_numbers_asociativity} spolu s~definicí, jak jdou čísla po sobě~v~tabulce~\ref{tab:natural_numbers} nám plně definují součet dvou čísel. Pro každý součet dvou čísel totiž můžeme postupně snižovat jedno číslo a~zvyšovat druhé, až získáme výsledek. Ukážeme si to na příkladu součtu 5 + 3:

\begin{prolog}
?-	print_validated_formula(
		'natural_numbers_add_example',
		equal([
			5 + 3,
			5 + par(2 + 1),
			5 + par(1 + 2),
			par(5 + 1) + 2,
			linebreak,
			6 + 2,
			6 + par(1 + 1),
			par(6 + 1) + 1,
			linebreak,
			7 + 1,
			8
		])
	).
\end{prolog}
\eeq{natural_numbers_add_example}

Součet můžeme také zobrazit na číselné ose, jak je vidět na obrázku \ref{img:soucet_ciselna_osa}. Na obrázku~\ref{img:komutativita_souctu_ciselna_osa} je znázorněna komutativita součtu a~na obrázku~\ref{img:asociativita_souctu_ciselna_osa} asociativita součtu.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{0}{5}
\drawboxrow{0}{0}{2}{fill=cyan}
\drawboxrow{2}{0}{3}{fill=orange}
\end{tikzpicture}
\caption{Grafické znázornění součtu \(\textcolor{cyan}{2} + \textcolor{orange}{3}\)}
\label{img:soucet_ciselna_osa}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{2}{8}
\drawboxrow{0}{2}{5}{fill=orange}
\drawboxrow{5}{2}{3}{fill=cyan}

\drawhnaturalnumberline{0}{0}{8}
\drawboxrow{0}{0}{3}{fill=cyan}
\drawboxrow{3}{0}{5}{fill=orange}
\end{tikzpicture}
\caption{Grafické znázornění komutativity součtu \(\textcolor{orange}{5} + \textcolor{cyan}{3} = \textcolor{cyan}{3} + \textcolor{orange}{5}\)}
\label{img:komutativita_souctu_ciselna_osa}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{2.5}{9}
\drawboxrow{0}{3}{2}{fill=cyan}
\drawboxrow{2}{3}{3}{fill=orange}
\drawboxrow{5}{2.5}{4}{fill=green}

\drawhnaturalnumberline{0}{0}{9}
\drawboxrow{0}{0.5}{2}{fill=cyan}
\drawboxrow{2}{0}{3}{fill=orange}
\drawboxrow{5}{0}{4}{fill=green}
\end{tikzpicture}
\caption{Grafické znázornění asociativity součtu \((\textcolor{cyan}{2} + \textcolor{orange}{3}) + \textcolor{green}{4} = \textcolor{cyan}{2} + (\textcolor{orange}{3} + \textcolor{green}{4})\)}
\label{img:asociativita_souctu_ciselna_osa}
\end{figure}

Pokračujme definicí součinu. Chceme-li vynásobit čísla \(a\) a~\(b\), pak \(b\)-krát sečteme číslo \(a\).

\begin{equation}
\label{eq:multiplication_definition}
c = a \cdot b = \overbrace{a + a + a + ...}^{b \times}
\end{equation}

Násobení můžeme znázornit graficky pomocí obdélníka. Podle definice \eqref{eq:multiplication_definition} musíme při výpočtu součinu \(a \cdot b\) sečíst \(b\) čísel \(a\). Pokud tedy číslo \(a\) představuje \(a\) objektů a~my je vyskládáme do jedné řady, pak součin \(a \cdot b\) může být zakreslen jako \(b\) takovýchto řad nad sebou. Například součin \(3 \cdot 4\) je zobrazen na obrázku~\ref{img:multiplication_definition}. 

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawnaturalnumberplane{0}{0}{3}{4};
\drawboxrect{0}{0}{3}{4}{fill=lightgray};
\end{tikzpicture}
\caption{Grafické znázornění součinu \(3 \cdot 4\)}
\label{img:multiplication_definition}
\end{figure}

Z~definice~\eqref{eq:multiplication_definition} přímo plynou dva vztahy. Vztah \eqref{eq:natural_multiply_by_one} nám udává, co znamená násobit číslem 1. Vztah~\eqref{eq:multiplication_distributivity} je tzv. distributivita násobení a~udává vztah mezi nádobením a~sčítáním.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_multiply_by_one',
		forall_in(A, 'a', natural_numbers, Values,
			equal([A * 1, A])
		)
	).				
\end{prolog}
\eeq{natural_multiply_by_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_distributivity',
		forall_in([A, B, C], ['a', 'b', 'c'], natural_numbers, Values,
			equal([A * (B + C), A * B + A * C])
		)
	).				
\end{prolog}
\eeq{multiplication_distributivity}
\end{fact}

Distributivitu součinu můžeme odvodit rozepsáním součinu pomocí definice, jak je vidět v rovnici~\eqref{eq:multiplication_distributivity_proof}. Graficky je distributivita znázorněna na obrázku~\ref{img:multiplication_distributivity}.

\begin{equation}
\label{eq:multiplication_distributivity_proof}
a \cdot (b + c) = \overbrace{a + a + a + ...}^{(b + c) \times} = \overbrace{a + a + a + ...}^{b \times} + \overbrace{a + a + a + ...}^{c \times} = a \cdot b + a \cdot c
\end{equation}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawnaturalnumberplane{0}{0}{4}{5};
\drawboxrect{0}{0}{4}{2}{fill=cyan};
\drawboxrect{0}{2}{4}{3}{fill=orange};
\end{tikzpicture}
\caption{Grafické znázornění distributivity součinu \(4 \cdot (\textcolor{cyan}{2} + \textcolor{orange}{3}) = 4 \cdot \textcolor{cyan}{2} + 4 \cdot \textcolor{orange}{3}\)}
\label{img:multiplication_distributivity}
\end{figure}

Zamyslíme-li se nad vztahy~\eqref{eq:natural_multiply_by_one} a~\eqref{eq:multiplication_distributivity}, tak zjistíme, že nám plně definují součin přirozených čísel. Pravý operand totiž můžeme postupně snižovat o~jedničku a~rozepsat součin na součet. Například pro součin \(3 \cdot 4\) získáme:

\begin{prolog}
?-	print_validated_formula(
		'multiplication_example',
		equal([
			3 * 4,
			3 * (3 + 1),
			3 * 3 + 3 * 1,
			3 * (2 + 1) + 3 * 1,
			linebreak,
			3 * 2 + 3 * 1 + 3 * 1,
			3 * (1 + 1) + 3 * 1 + 3 * 1,
			linebreak,
			3 * 1 + 3 * 1 + 3 * 1 + 3 * 1,
			3 + 3 + 3 + 3,
			12
		])
	).				
\end{prolog}
\eeq{multiplication_example}

Původní definici tedy můžeme nahradit formálními rovnicemi~\eqref{eq:natural_multiply_by_one} a~\eqref{eq:multiplication_distributivity}.

Z~grafické reprezentace součinu je také vidět, že součin je komutativní operace. Obdélníku totiž můžeme prohodit strany, aniž by se tím změnil jeho obsah. Počet objektů, na obrázku~\ref{img:multiplication_comutativity} znázorněných počtem čtverců, se tím nezmění. Jinak řečeno, máme-li \(b\) skupin (na levém obrázku řádků) po \(a\) objektech, pak je můžeme přeskupit tak, že budeme mít \(a\) skupin po \(b\) objektech. Přeskupením se počet objektů nezmění. Komutativitu součinu popisuje rovnice~\eqref{eq:multiplication_comutativity}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawnaturalnumberplane{0}{0}{3}{4};
\drawboxrect{0}{0}{3}{4}{fill=orange};

\drawnaturalnumberplane{5}{0}{4}{3};
\drawboxrect{5}{0}{4}{3}{fill=cyan};
\end{tikzpicture}
\caption{Grafické znázornění komutativity součinu \(\textcolor{orange}{3 \cdot 4} = \textcolor{cyan}{4 \cdot 3}\)}
\label{img:multiplication_comutativity}
\end{figure}

Obdobně můžeme uvažovat o~asociativitě součinu popsaného rovnicí~\eqref{eq:multiplication_asociativity}. Výraz \(a \cdot b \cdot c\) odpovídá objemu kvádru, v~případě přirozených čísel \(a\), \(b\) a~\(c\) počtu jednotkových krychlí naskládaných do kvádru. Postavením kvádru na jinou stranu se jeho objem - počet jednotkových krychlí - nezmění. Proto součin musí být asociativní operace.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_comutativity',
		forall_in([A, B], ['a', 'b'], natural_numbers, Values,
			equal([A * B, B * A])
		)
	).				
\end{prolog}
\eeq{multiplication_comutativity}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_asociativity',
		forall_in([A, B, C], ['a', 'b', 'c'], natural_numbers, Values,
			equal([par(A * B) * C, A * par(B * C)])
		)
	).				
\end{prolog}
\eeq{multiplication_asociativity}
\end{fact}

Nakonec rovnicí~\eqref{eq:power_definition} definujeme mocninu jako opakované násobení.

\begin{equation}
\label{eq:power_definition}
a^b = \overbrace{a \cdot a \cdot a \cdot ...}^{b \times}
\end{equation}

Opět můžeme z~této definice odvodit rovnice~\eqref{eq:natural_power_by_one} a~\eqref{eq:natural_power_distributivity}, které nám plně definují mocniny přirozených čísel.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_power_by_one',
		forall_in(A, 'a', natural_numbers, Values,
			equal([A^1, A])
		)
	).				
\end{prolog}
\eeq{natural_power_by_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_power_distributivity',
		forall_in([A, B, C], ['a', 'b', 'c'], natural_numbers, Values,
			equal([A^(B + C), A^B * A^C])
		)
	).				
\end{prolog}
\eeq{natural_power_distributivity}
\end{fact}

Na rozdíl od sčítání a~násobení není umocňování komutativní operace (\(2^3 = 8 \neq 3^2 = 9\)) ani asociativní operace (\((4^3)^2 = 4096 \neq 4^{(3^2)} = 262144\)). Nicméně některé zákonitosti zde platí. Dokážeme rovnici~\eqref{eq:power_by_multiplication_proof}.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof',
		forall_in([A, B, C], ['a', 'b', 'c'], natural_numbers, Values,
			equal([(A^B)^C, A^(B * C)])
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof}
\end{fact}

Mocniny bohužel není možné jednoduše graficky znázornit jako násobení nebo sčítání. Rovnici proto dokážeme matematickou indukcí. Nejdříve ověříme platnost rovnice pro \(c = 1\):

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof_1',
		forall_in([A, B], ['a', 'b'], natural_numbers, Values,
			equal([(A^B)^1, A^B, A^(B * 1)])
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof_1}

Dále ověříme platnost výroku~\eqref{eq:power_by_multiplication_proof_2} a~to pomocí rovnice~\eqref{eq:power_by_multiplication_proof_3}.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof_2',
		forall_in([A, B, C], ['a', 'b', 'c'], natural_numbers, Values,
			impl(
				equal([(A^B)^C, 	A^(B*C)]),
				equal([(A^B)^(C+1), 	A^(B*(C+1))])
			)
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof_2}

V~prvním kroku jsme využili distributivitu násobení. Ve druhém kroku jsme využili předpoklad z~výroku~\eqref{eq:power_by_multiplication_proof_2}. Nakonec jsme opět využili distributivitu násobení, tentokrát opačným směrem, a~upravili exponent do požadovaného tvaru. Tím je rovnice~\eqref{eq:power_by_multiplication_proof} dokázána pro všechna přirozená čísla.

\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof_3',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				declare_variable(C, 'c', Values,
					equal([
						(A^B)^(C + 1),
						(A^B)^C * (A^B)^1,
						A^(B*C) * A^B,
						A^(B*C + B),
						A^(B*(C+1))
					])
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof_3}

Dále dokažme rovnici~\eqref{eq:power_of_multiplication_proof}.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'power_of_multiplication_proof',
		forall_in([A, B, N], ['a', 'b', 'n'], natural_numbers, Values,
			equal((A*B)^N, A^N * B^N)
		)
	).
\end{prolog}
\eeq{power_of_multiplication_proof}
\end{fact}

Její důkaz opět provedeme matematickou indukcí. Ověření rovnice pro \(n = 1\) je triviální:

\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_of_multiplication_proof_1',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					(A*B)^1,
					A*B,
					A^1 * B^1
				])
			)
		)
	).
\end{prolog}
\eeq{power_of_multiplication_proof_1}

Dále dokážeme, že z~\((a \cdot b)^n = a^n \cdot b^n\) plyne \((a \cdot b)^{n+1} = a^{n+1} \cdot b^{n+1}\).

\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_of_multiplication_proof_2',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				declare_variable(N, 'n', Values,
					equal([
						(A*B)^(N+1),
						(A*B)^N * A*B,
						A^N * B^N * A*B,
						linebreak,
						par(A^N * A) * par(B^N * B),
						A^(N+1) * B^(N+1)
					])
				)
			)
		)
	).
\end{prolog}
\eeq{power_of_multiplication_proof_2}

Tím je rovnice~\eqref{eq:power_of_multiplication_proof} dokázána pro všechna přirozená čísla.

\section{Celá čísla}

Zkusme dále definovat rozdíl jako opačnou operaci k~součtu pomocí věty~\eqref{eq:difference_definition}.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'difference_definition',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				declare_variable(C, 'c', Values,
					equiv(
						equal([C, A - B]),
						equal([B + C, A])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{difference_definition}

Z této věty například vyplývá, že \(5 - 2 = 3\) protože \(2 + 3 = 5\). Vidíme ale, že pro některé dvojice přirozených čísel rozdíl neexistuje. Například nelze vypočítat \(2 - 3\), protože neexistuje přirozené číslo, které kdybychom přičetli k číslu 3, tak dostaneme číslo 2. Potřebovali bychom číslo, které je menší než nejmenší přirozené číslo 1. Abychom mohli taková čísla zavést, tak musíme opustit náš dosavadní model reprezentace čísel pomocí počtu jedniček nebo objektů a~definovat čísla jejich pořadím podle tabulky~\ref{tab:integers}. Celá čísla můžeme zobrazit na číselné ose jako na obrázku~\ref{img:integer_number_line}.

\begin{table}[ht]
\centering
\begin{tabular}{|r|r|}
\hline
Číslo & Pořadí \\
\hline
\ldots & \ldots \\
-4 & -5 + 1 \\
-3 & -4 + 1 \\
-2 & -3 + 1 \\
-1 & -2 + 1 \\
0 & -1 + 1 \\
1 & 0 + 1 \\
2 & 1 + 1 \\
3 & 2 + 1 \\
4 & 3 + 1 \\
\ldots & \ldots \\
\hline
\end{tabular}
\caption{Celá čísla}
\label{tab:integers}
\end{table}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};
\end{tikzpicture}
\caption{Číselná osa}
\label{img:integer_number_line}
\end{figure}

Operace součtu zůstává definovaná pomocí tohoto pořadí a~rovnic~\eqref{eq:natural_numbers_comutativity} a~\eqref{eq:natural_numbers_asociativity}. Součet můžeme znázornit na číselné ose, jak je zobrazeno na obrázku~\ref{img:integer_add}. Abychom mohli zobrazit i~záporné sčítance, tak namísto čtverců použijeme šipky. U~kladných sčítanců míří šipka doprava, u~záporných sčítanců doleva.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};
\draw[dotted] (0, 0) -- (0, 0.5);
\draw[->, color=cyan] (0, 0.5) -- (2, 0.5);
\draw[dotted] (2, 0.5) -- (2, 1);
\draw[->, color=orange] (2, 1) -- (-1, 1);
\end{tikzpicture}
\caption{Grafické znázornění součtu \(\textcolor{cyan}{2} + (-\textcolor{orange}{3})\)}
\label{img:integer_add}
\end{figure}

Komutativita součtu je znázorněna na obrázku~\ref{img:integer_add_comutativity} a~asociativita na obrázku~\ref{img:integer_add_asociativity}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}

\drawhintegerline{0}{2}{-4}{4};
\draw[dotted] (0, 2) -- (0, 2.5);
\draw[->, color=cyan] (0, 2.5) -- (2, 2.5);
\draw[dotted] (2, 2.5) -- (2, 3);
\draw[->, color=orange] (2, 3) -- (-1, 3);

\drawhintegerline{0}{0}{-4}{4};
\draw[dotted] (0, 0) -- (0, 0.5);
\draw[->, color=orange] (0, 0.5) -- (-3, 0.5);
\draw[dotted] (-3, 0.5) -- (-3, 1);
\draw[->, color=cyan] (-3, 1) -- (-1, 1);

\end{tikzpicture}
\caption{Grafické znázornění komutativity součtu \(\textcolor{cyan}{2} + (-\textcolor{orange}{3}) = -\textcolor{orange}{3} + \textcolor{cyan}{2}\)}
\label{img:integer_add_comutativity}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tikzpicture}

\drawhintegerline{0}{3}{-4}{4};
\draw[dotted] (0, 3) -- (0, 3.5);
\draw[->, color=cyan] (0, 3.5) -- (2, 3.5);
\draw[dotted] (2, 3.5) -- (2, 4);
\draw[->, color=orange] (2, 4) -- (-1, 4);
\draw[dotted] (-1, 4) -- (-1, 4.5);
\draw[->, color=green] (-1, 4.5) -- (3, 4.5);

\drawhintegerline{0}{0}{-4}{4};
\draw[dotted] (0, 0) -- (0, 1);
\draw[->, color=cyan] (0, 0.5) -- (2, 0.5);

\draw[->, color=orange] (0, 1) -- (-3, 1);
\draw[dotted] (-3, 1) -- (-3, 1.5);
\draw[->, color=green] (-3, 1.5) -- (1, 1.5);

\draw[->] (2, 0.5) -- (3, 0.5);
\draw[->] (0, 1) -- (1, 1);
\draw[dotted] (1, 1) -- (1, 1.5);
\draw[dotted] (2, 0.5) -- (0, 1);
\draw[dotted] (3, 0.5) -- (1, 1);
\end{tikzpicture}
\caption{Grafické znázornění asociativity součtu \((\textcolor{cyan}{2} + (-\textcolor{orange}{3})) + \textcolor{green}{4} = \textcolor{cyan}{2} + (-\textcolor{orange}{3} + \textcolor{green}{4})\)}
\label{img:integer_add_asociativity}
\end{figure}


Operace rozdílu je definovaná větou~\eqref{eq:difference_definition} a~každé dvojici celých čísel přiřazuje celé číslo. Říkáme, že množina celých čísel je uzavřená pro operaci odčítání (to množina přirozených čísel nebyla).


Mezi celými čísly najdeme zvláštní číslo 0. Z~definice čísla 1 v~tabulce~\ref{tab:integers} vidíme, že \(0 + 1 = 1\), tedy když k~jedničce přičteme nulu, tak získáme zase jedničku. To platí obecně:

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'add_zero_proof_1',
		declare_variable(B, 'b', Values,
			equal([
				par(B + 1) + 0,
				B + par(0 + 1),
				B + 1
			])
		)
	).
\end{prolog}
\eeq{add_zero_proof_1}

V~prvním kroku jsme s~využitím komutativity a~asociativity sčítání výraz přeuspořádali. Ve druhém kroku jsme využili definice čásla 1. Protože každé celé číslo má svého předchůdce, tak můžeme zavést substituci \(a = b + 1\):

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'add_zero_proof_2',
		declare_variable(A, 'a', Values,
			equal([
				A + 0,
				A
			])
		)
	).
\end{prolog}
\eeq{add_zero_proof_2}

Vidíme, že přičtením nuly k~jakémukoli číslu se toto číslo nezmění.
Srovnáme-li vztah~\eqref{eq:add_zero_proof_2} se vztahem \eqref{eq:difference_definition}, dostaneme:

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'difference_itself',
		declare_variable(A, 'a', Values,
			equal([
				A - A,
				0
			])
		)
	).
\end{prolog}
\eeq{difference_itself}

Vidíme, že rovnicí~\eqref{eq:opposite_number_definition} můžeme ke každému číslu \(a\) zavést tzv. opačné číslo \(-a\). Toto číslo můžeme vypočítat podle vztahu~\eqref{eq:opposite_number_calculation}. Teď už také rozumíme proč se záporná čísla zapisují se znaménkem minus.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'opposite_number_definition',
		declare_variable(A, 'a', Values,
			equal([
				A + par(-A),
				0
			])
		)
	).
\end{prolog}
\eeq{opposite_number_definition}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'opposite_number_calculation',
		declare_variable(A, 'a', Values,
			equal([
				-A,
				0 - A
			])
		)
	).
\end{prolog}
\eeq{opposite_number_calculation}

Opačná čísla nám umožňují vypočítat rozdíl pomocí součtu jak je vidět v~rovnici~\eqref{eq:difference_by_add}.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'difference_by_add',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					A - B,
					A + 0 - B,
					A + par(-B)
				])
			)
		)
	).
\end{prolog}
\eeq{difference_by_add}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};
\end{tikzpicture}
\caption{Číselná osa}
\label{img:integer_number_line}
\end{figure}

Nakonec odvodíme vztah pro opačné číslo opačného čísla. Vyjdeme z~definice opačného čísla~\eqref{eq:opposite_number_definition}. V~prvním kroku použijeme definici rozdílu~\eqref{eq:difference_definition}. Nakonec použijeme vztah~\eqref{eq:opposite_number_calculation}. Vidíme, že opačné číslo opačného čísla je původní číslo. Neboli, jak se říká, dvakrát minus dává plus:

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'double_opposite_proof',
		declare_variable(A, 'a', Values,
			proof([],
			[
				equal(0, A + par(-A)),
				equal(0 - par(-A), A),
				equal(-(-A), A)
			])
		)
	).
\end{prolog}
\eeq{double_opposite_proof}

Pokračujme rozšířením součinu na celá čísla. Začněme nulou. Srovnáním členů v~rovnici~\eqref{eq:multiplication_by_zero_1} lze odvodit vztah~\eqref{eq:multiplication_by_zero_2}.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_zero_1',
		declare_variable(A, 'a', Values,
			equal([
				A * 1,
				A * (1 + 0),
				A * 1 + A * 0
			])
		)
	).
\end{prolog}
\eeq{multiplication_by_zero_1}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_zero_2',
		declare_variable(A, 'a', Values,
			equal([A * 0, 0])
		)
	).
\end{prolog}
\eeq{multiplication_by_zero_2}

Pokračujme součinem, kde je jeden operand záporný. Z~rovnice~\eqref{eq:multiplication_by_negative_1} plyne vztah~\eqref{eq:multiplication_by_negative_2}. Díky komutativitě součinu můžeme v~rovnici~\eqref{eq:multiplication_by_negative_3} odvodit totéž pro první operand. 

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_1',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					0,
					A * (-B + B),
					A * (-B) + A * B
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_1}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_2',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					A * (-B), -par(A * B)
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_2}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_3',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					(-A) * B,
					B * (-A),
					-par(B * A),
					-par(A * B)
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_3}

Nakonec v~rovnici~\eqref{eq:multiplication_by_negative_4} vyšetříme případ, kdy jsou oba operandy záporné.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_4',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					(-A) * (-B),
					-par(A * (-B)),
					-par(-par(A * B)),
					A * B
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_4}

\section{Racionální čísla}

Definujme podíl jako opačnou operaci k~násobení pomocí věty~\eqref{eq:division_definition}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'division_definition',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				declare_variable(C, 'c', Numbers,
					equiv(
						equal([C, A / B]),
						equal([B * C, A])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{division_definition}

Z~této věty například vyplývá, že \(\frac{6}{3} = 2\) protože \(3 \cdot 2 = 6\). Vidíme ale, že pro některé dvojice celých čísel podíl neexistuje. Například nelze vypočítat \(\frac{3}{2}\), protože neexistuje celé číslo, které kdybychom vynásobili číslem 2, tak dostaneme číslo 3. Potřebovali bychom číslo, které je větší než 1 a~menší než 2. Toto omezení celých čísel můžeme obejít tak, že jako číslo definujeme podíl dvou celých čísel a~nazveme ho racionální číslo. Množinu všech racionálních čísel označíme \(\rationals\):

\begin{equation}
\forall a \in \integers \ \forall b \in (\integers \setminus \{0\}) \ \frac{a}{b} \in \rationals
\end{equation}

Racionální čísla jsou tedy zlomky. Číslu, které dělíme, říkáme čitatel. Číslu, kterým děláme, říkáme jmenovatel. Jmenovatel nemůže být nulový. Podle věty~\eqref{eq:division_definition} bychom pro \(b = 0\) totiž museli najít hodnotu \(c\) splňující podmínku \(0 \cdot c = a\). Mohou nastat dva případy:

\begin{itemize}
	\item \(a = 0\), pak může být \(c\) jakékoli.
	\item \(a \neq 0\), pak odpovídající hodnota \(c\) neexistuje. 
\end{itemize}

V~obou případech nemá zlomek definovanou hodnotu. Proto nulou dělit nelze.

Graficky lze kladná racionální čísla zobrazit jako boxy. Čitatel určuje počet boxů, jmenovatel kolik boxů se vejde do jednotky. Racionální čísla tedy mohou být mezi celými čísly jak vidíme na obrázku~\ref{img:rational_definition}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-1}{2}
\drawboxrowrational{0}{0}{3}{2}{1}{fill=lightgray}
\end{tikzpicture}
\caption{Grafické znázornění racionálního čísla \(\frac{3}{2}\)}
\label{img:rational_definition}
\end{figure}

Vyjádřeme násobení racionálních čísel v~soustavě~\eqref{eq:rational_multiplication}. Mějme dvě racionální čísla \(c\) a~\(f\) zapsaná jako zlomky. Potom můžeme podle věty~\eqref{eq:division_definition} zapsat jejich definici součinem. Z~nich můžeme vyjádřit součin \(a \cdot d\), ze kterého podle věty~\eqref{eq:division_definition} vyjádříme součin racionálních čísel.

\begin{prolog}
?-	Numbers = [1, 2, 3, 4, 6],
	print_validated_formula(
		'rational_multiplication',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					declare_variable(D, 'd', Numbers,
						declare_variable(E, 'e', Numbers,
							declare_variable(F, 'f', Numbers,
								proof([
									equal([C, A / B]),
									equal([F, D / E])
								],
								[
									equal([A, B * C]),
									equal([D, E * F]),
									equal([A * D, par(B * C) * par(E * F), par(B * E) * par(C * F)]),
									equal([(C * F), (A / B) * (D / E), (A * D) / (B * E)])
								])
							)
						)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{rational_multiplication}

Graficky můžeme znázornit násobení racionálních čísel jako na obrázku~\ref{img:rational_multiplication_definition}.
Je zde obdélník, jehož strany mají délku danou násobenými čísly. Tyto strany mají počet boxů daný čitateli násobených čísel a~velikost boxů je taková, aby se do jednotky vešel počet boxů odpovídající jmenovateli násobených čísel. Součin je zlomek. Čitatel součinu odpovídá celkovému počtu boxů, tedy součinu čitatelů násobených čísel. Jmenovatel součinu odpovídá počtu boxů, které se vejdou do jednotkového čtverce, tedy součinu jmenovatelů násobených čísel. V~uvedeném příkladě tedy máme 15 boxů, přičemž 6 boxů tvoří jednotkový čtverec (na obrázku šedě podbarveno). Je zřejmé, že i~součin racionálních čísel je komutativní a~asociativní, protože jsou komutativní a~asociativní součiny čísel v~čitatelích a jmenovatelích. Graficky je komutativita znázorněna na obrázku~\ref{img:rational_multiplication_comutativity}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawrect{0}{0}{1}{1}{fill=lightgray};
\drawnaturalnumberplane{0}{0}{2}{2};
\drawboxrectrational{0}{0}{3}{2}{5}{3}{fill=orange};
\end{tikzpicture}
\caption{Grafické znázornění součinu \(\frac{3}{2} \cdot \frac{5}{3} = \frac{15}{6}\)}
\label{img:rational_multiplication_definition}
\end{figure}


\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawrect{0}{0}{1}{1}{fill=lightgray};
\drawnaturalnumberplane{0}{0}{2}{2};
\drawboxrectrational{0}{0}{3}{2}{5}{3}{fill=orange};

\drawrect{3}{0}{4}{1}{fill=lightgray};
\drawnaturalnumberplane{3}{0}{2}{2};
\drawboxrectrational{3}{0}{5}{3}{3}{2}{fill=cyan};
\end{tikzpicture}
\caption{Grafické znázornění komutativity součinu \(\textcolor{orange}{\frac{3}{2} \cdot \frac{5}{3}} = \textcolor{cyan}{\frac{5}{3} \cdot \frac{3}{2}}\)}
\label{img:rational_multiplication_comutativity}
\end{figure}

Z~definice~\eqref{eq:division_definition} dále plyne vztah~\eqref{eq:rational_one} definující podíl stejných čísel.

\begin{prolog}
?-	make_test_nonzero_numbers(Numbers),
	print_validated_formula(
		'rational_one',
		declare_variable(A, 'a', Numbers,
			equal([A / A, 1])
		)
	).
\end{prolog}
\eeq{rational_one}

Ze vztahů~\eqref{eq:rational_multiplication} a~\eqref{eq:rational_one} můžeme odvodit vztah~\eqref{eq:rational_reduction} umožňující rozšíření nebo naopak krácení zlomků. Tento vztah nám umožňuje zapsat racionální čísla ve tvaru, kdy jmenovatel je přirozené číslo (tedy kladný) a~čitatel a~jmenovatel jsou nesoudělní.

\begin{prolog}
?-	make_test_nonzero_numbers(Numbers),
	print_validated_formula(
		'rational_reduction',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					equal([
						A / B,
						(A / B) * 1,
						(A / B) * (C / C),
						(A * C) / (B * C)
					])
				)
			)
		)
	).
\end{prolog}
\eeq{rational_reduction}

Dále můžeme odvodit vztah~\eqref{eq:division_distributivity} pro distributivitu podílu. Tento vztah nám umožňuje vypočítat součet a~rozdíl zlomků se stejným jmenovatelem.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'division_distributivity',
		declare_plus_minus(PM,
			declare_variable(A, 'a', Numbers,
				declare_variable(B, 'b', Numbers,
					declare_variable(C, 'c', NonzeroNumbers,
						equal([
							plus_minus(A, B, PM) / C,
							plus_minus(A, B, PM) * (1 / C),
							plus_minus(A * (1 / C), B * (1 / C), PM),
							plus_minus(A / C, B / C, PM)
						])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{division_distributivity}

Pokud chceme vypočítat součet nebo rozdíl zlomků s~rozdílnými jmenovateli, pak je musíme převést na společného jmenovatele, jak je vidět ve vztahu~\eqref{eq:sum_of_rationals}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'sum_of_rationals',
		declare_plus_minus(PM,
			declare_variable(A, 'a', Numbers,
				declare_variable(B, 'b', NonzeroNumbers,
					declare_variable(C, 'c', Numbers,
						declare_variable(D, 'd', NonzeroNumbers,
							equal([
								plus_minus(A / B, C / D, PM),
								plus_minus((A * D) / (B * D), (C * B) / (D * B), PM),
								plus_minus(A * D, B * C, PM) / (B * D)
							])
						)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{sum_of_rationals}

Graficky je součet racionálních čísel zobrazen na obrázku~\ref{img:add_rational_numbers}. Sčítáme třetiny a~poloviny, ty mají ale jinak veliké boxy. Proto každý třetinový box rozdělíme na dva stejné a~každý polovinový box rozdělíme na tři stejné. Získáme tak boxy o~velikosti jedné šestiny jednotky, ty pak už můžeme sčítat.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawboxrowrational{0}{1}{4}{3}{1}{fill=cyan}
\drawboxrowrational{4 / 3}{1}{3}{2}{1}{fill=orange}

\drawhintegerline{0}{0}{0}{3}
\drawboxrowrational{0}{0}{8}{6}{1}{fill=cyan}
\drawboxrowrational{4 / 3}{0}{9}{6}{1}{fill=orange}
\end{tikzpicture}
\caption{Grafické znázornění součtu \(\textcolor{cyan}{\frac{4}{3}} + \textcolor{orange}{\frac{3}{2}} = \textcolor{cyan}{\frac{8}{6}} + \textcolor{orange}{\frac{9}{6}} = \frac{17}{6}\)}
\label{img:add_rational_numbers}
\end{figure}

Dále můžeme rovnicí~\eqref{eq:division_of_rationals} vyjádřit podíl racionálních čísel.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'division_of_rationals',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				declare_variable(C, 'c', NonzeroNumbers,
					declare_variable(D, 'd', NonzeroNumbers,
						equal([
							(A / B) / (C / D),
							((A / B) / (C / D)) * ((D / C) / (D / C)),
							((A * D) / (B * C)) / ((C * D) / (D * C)),
							((A * D) / (B * C)) / 1,
							(A * D) / (B * C)
						])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{division_of_rationals}

Nakonec rozšiřme definici mocniny na racionální mocněnce a~celočíselné mocnitele. Začněme rozšířením mocněnce. Podle definice~\eqref{eq:power_definition} je zřejmé, že mezi sebou budeme násobit racionální čísla. Rovnice~\eqref{eq:natural_power_by_one} a~\eqref{eq:natural_power_distributivity} proto zůstanou zachovány i~pro racionální mocněnce, jak udávají rovnice~\eqref{eq:rational_power_by_one} a~\eqref{eq:rational_power_distributivity}.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'rational_power_by_one',
		forall_in(A, 'a', rational_numbers, Values,
			equal([A^1, A])
		)
	).				
\end{prolog}
\eeq{rational_power_by_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'rational_power_distributivity',
		forall_in(A, 'a', difference(rational_numbers, set_of([0])), Values,
			forall_in([B, C], ['b', 'c'], integers, Values,
				equal([A^(B + C), A^B * A^C])
			)
		)
	).				
\end{prolog}
\eeq{rational_power_distributivity}
\end{fact}

Přejděme dále k~rozšíření mocnitele (exponentu) na celá čísla. Rovnici~\eqref{eq:power_by_zero_1} můžeme vydělit \(a^1\) a~získáme vztah~\eqref{eq:power_by_zero_2}.

\begin{prolog}
?-	make_test_nonzero_integers(Values),
	print_validated_formula(
		'power_by_zero_1',
		declare_variable(A, 'a', Values,
			equal([
				A^1,
				A^(0 + 1),
				A^0 * A^1
			])
		)
	).
\end{prolog}
\eeq{power_by_zero_1}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'power_by_zero_2',
		declare_variable(A, 'a', Values,
			impl(
				not_equal(A, 0),
				equal([A^0, 1])
			)
		)
	).
\end{prolog}
\eeq{power_by_zero_2}

Zbývá vyšetřit hodnotu \(0^0\). Vztah~\eqref{eq:power_by_zero_2} naznačuje, že by mohlo platit \(0^0 = 1\), protože pro ostatní mocněnce umocnené na nulu dostáváme hodnotu 1. Naopak definice~\eqref{eq:power_definition} naznačuje, že by mohlo platit \(0^0 = 0\), protože nula na cokoli je rovna nule - násobíme mezi sebou samé nuly. Díky tomuto rozporu nemá výraz \(0^0\) definovanou hodnotu.

Dále můžeme s~racionálními čísly vyjádřit mocniny se zápornými exponenty. Z~rovnice~\eqref{eq:power_by_negative_exponent_1} plyne rovnice~\eqref{eq:power_by_negative_exponent_2}. Speciálním případem je rovnice~\eqref{eq:power_by_negative_exponent_3} udávající, že umocnění čísla na \(-1\) je rovno jeho převrácené hodnotě.

\begin{prolog}
?-	make_test_nonzero_integers(TestBases),
	make_test_integers(TestExponents),
	print_validated_formula(
		'power_by_negative_exponent_1',
		declare_variable(A, 'a', TestBases,
			declare_variable(B, 'b', TestExponents,
				impl(
					not_equal(A, 0),
					equal([
						1,
						A^0,
						A^(-B + B),
						A^(-B) * A^B
					])
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_negative_exponent_1}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_nonzero_integers(TestBases),
	make_test_integers(TestExponents),
	print_validated_formula(
		'power_by_negative_exponent_2',
		declare_variable(A, 'a', TestBases,
			declare_variable(B, 'b', TestExponents,
				impl(
					not_equal(A, 0),
					equal([A^(-B), 1 / (A^B)])
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_negative_exponent_2}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_nonzero_integers(TestBases),
	print_validated_formula(
		'power_by_negative_exponent_3',
		declare_variable(A, 'a', TestBases,
			impl(
				not_equal(A, 0),
				equal([A^(-1), 1 / A])
			)
		)
	).
\end{prolog}
\eeq{power_by_negative_exponent_3}

\section{Uspořádání čísel}

Operátor rovnosti už známe ze sekce~\ref{sec:equality_operator}. Nyní definujeme, která čísla jsou menší a~která jsou větší. Idea je taková, že máme-li dvě celá (a~tedy i~přirozená) čísla, tak se z~menšího čísla můžeme udělat větší postupným přičítáním jedniček. Větší číslo je tedy v~tabulce~\ref{tab:integers} níže a~menší číslo výše. Uděláme-li rozdíl mezi větším a~menším číslem, tak tedy vyjde kladný. Proto definujeme:

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_equal',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					equal(A, B),
					equal(A - B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_equal}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_than(A, B),
					less_than(A - B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_than}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_greater_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					greater_than(A, B),
					greater_than(A - B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_greater_than}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_or_equal',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_or_equal(A, B),
					or(
						less_than(A, B),
						equal(A, B)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_or_equal}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_greater_or_equal',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					greater_or_equal(A, B),
					or(
						greater_than(A, B),
						equal(A, B)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_greater_or_equal}
\end{fact}

Stačí tedy definovat, která čísla jsou kladná a~která záporná. Začněme celými čísly. Zde je situace jednoduchá - přirozená čísla jsou kladná a~k~nim opačná čísla jsou záporná:

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_positive_integers',
		forall_in(N, 'n', natural_numbers, Numbers,
			greater_than(N, 0)
		)
	).
\end{prolog}
\eeq{order_positive_integers}
%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_positive_negative',
		forall_in(N, 'n', natural_numbers, Numbers,
			less_than(-N, 0)
		)
	).
\end{prolog}
\eeq{order_positive_negative}
\end{fact}

Přejděme k~racionálním číslům. Podle rovnice~\eqref{eq:order_rationals_1} můžeme každé racionální číslo rozšířit tak, že jeho jmenovatel bude kladný. Potom je znaménko určeno čitatelem takto rozšířeného zlomku. Platí proto vztahy~\eqref{eq:order_rationals_positive} a~\eqref{eq:order_rationals_negative}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'order_rationals_1',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				equal(A / B, (A * B) / (B * B))
			)
		)
	).
\end{prolog}
\eeq{order_rationals_1}

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'order_rationals_positive',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				equiv(
					greater_than(A / B, 0),
					greater_than(A * B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_rationals_positive}
%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'order_rationals_negative',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				equiv(
					less_than(A / B, 0),
					less_than(A * B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_rationals_negative}
\end{fact}

Graficky můžeme zobrazit uspořádání čísel na číselné ose jako na obrázku~\ref{img:ordering}. Plným kroužkem je zobrazeno číslo 1. Vlevo od něj je zobrazena množina čísel menších než 1. Vpravo pak množina čísel větších než 1. Prázdné kroužky znamenají, že číslo 1 není v~těchto množinách obsaženo. Šipky na konci znamenají, že množina pokračuje do plus nebo minus nekonečna. 

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};

\drawpointset{1}{1.5};
\draw (1, 1.6) node[anchor=south]{\(x = 1\)};

\drawinfopenset{-4.2}{0.5}{1}{0.5};
\draw (-1.5, 0.5) node[anchor=south]{\(\{x: x < 1\}\)};

\drawopeninfset{1}{1}{4.2}{1};
\draw (2.5, 1) node[anchor=south]{\(\{x: x > 1\}\)};

\end{tikzpicture}
\caption{Grafické znázornění uspořádání čísel}
\label{img:ordering}
\end{figure}

Z~definic~\eqref{eq:order_less_than} a~\eqref{eq:order_at_least_one} také plynou věty~\eqref{eq:order_not_less_than} až~\eqref{eq:order_less_or_equal_opposite}. Tyto věty vyjadřují fakt, že vždy platí právě jedna z~relací \(a < b\), \(a = b\), \(a > b\). Důkaz nechám na čtenáři, stačí vždy danou relaci pomocí definic~\eqref{eq:order_less_than} a~\eqref{eq:order_at_least_one} převést na porovnání s~nulou.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_at_least_one',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				or(
					or(
						less_than(A, B),
						equal(A, B)
					),
					greater_than(A, B)
				)
			)
		)
	).
\end{prolog}
\eeq{order_at_least_one}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_not_less_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					not(less_than(A, B)),
					greater_or_equal(A, B)
				)
			)
		)
	).
\end{prolog}
\eeq{order_not_less_than}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_not_greater_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					not(greater_than(A, B)),
					less_or_equal(A, B)
				)
			)
		)
	).
\end{prolog}
\eeq{order_not_greater_than}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_than_opposite',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_than(A, B),
					greater_than(B, A)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_than_opposite}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_or_equal_opposite',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_or_equal(A, B),
					greater_or_equal(B, A)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_or_equal_opposite}
\end{fact}

Předpokládejme dále, že platí \(a > b\) a \(b > c\). Tyto relace nejdříve rozepíšeme podle definice~\eqref{eq:order_less_than}. Následně využijeme faktu, že součet kladných čísel je kladné číslo (viz věty~\eqref{eq:order_positive_integers} a~\eqref{eq:order_rationals_positive}). Úpravou pak získáme \(a > c\). Výsledek je zapsán ve větě~\eqref{eq:order_transitivity_greater_than} a~říká, že relace menší než (a~větší než) je tranzitivní. Obdobně platí věta~\eqref{eq:order_transitivity_less_than}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_transitivity_proof',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					proof([
						greater_than(A, B),
						greater_than(B, C)
					],
					[
						greater_than(A - B, 0),
						greater_than(B - C, 0),
						greater_than(par(A - B) + par(B - C), 0),
						greater_than(A - C, 0),
						greater_than(A, C)
					])
				)
			)
		)
	).
\end{prolog}
\eeq{order_transitivity_proof}

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_transitivity_greater_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					impl(
						and(
							greater_than(A, B),
							greater_than(B, C)
						),
						greater_than(A, C)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_transitivity_greater_than}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_transitivity_less_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					impl(
						and(
							less_than(A, B),
							less_than(B, C)
						),
						less_than(A, C)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_transitivity_less_than}
\end{fact}

Graficky je tranzitivita zobrazena na obrázku~\ref{img:ordering_transitivity}. Díky tranzitivitě platí, že jakékoli číslo z~množiny \(A\) je menší než jakékoli číslo z~množiny \(C\).

\begin{figure}[!h]
\centering
\begin{tikzpicture}

\drawinfopenset{-4.2}{0.5}{0}{0.5};
\draw (-2, 0.5) node[anchor=south]{\(A = \{a: a < b\}\)};

\drawopeninfset{0}{1}{4.2}{1};
\draw (2, 1) node[anchor=south]{\(C = \{c: c > b\}\)};

\draw (0, -0.2) -- (0, 0.2);
\draw (0, -0.2) node[anchor=north]{\(b\)};

\draw[<->] (-4.5, 0) -- (4.5, 0);
\end{tikzpicture}
\caption{Grafické znázornění tranzitivity uspořádání čísel}
\label{img:ordering_transitivity}
\end{figure}

Minimem množiny rozumíme její nejmenší prvek, maximem její nejvyšší prvek. Popisují je věty~\eqref{eq:min_definition_1} až~\eqref{eq:max_definition_2}.

\begin{fact}
\begin{prolog}
?-	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'min_definition_1',
		declare_variable(M, 'M', Sets,
			in(min(M), M)
		)
	).
\end{prolog}
\eeq{min_definition_1}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'min_definition_2',
		declare_variable(M, 'M', Sets,
			forall_in(X, 'x', M, Numbers, greater_or_equal(X, min(M)))
		)
	).
\end{prolog}
\eeq{min_definition_2}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'max_definition_1',
		declare_variable(M, 'M', Sets,
			in(max(M), M)
		)
	).
\end{prolog}
\eeq{max_definition_1}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'max_definition_2',
		declare_variable(M, 'M', Sets,
			forall_in(X, 'x', M, Numbers, less_or_equal(X, max(M)))
		)
	).
\end{prolog}
\eeq{max_definition_2}
\end{fact}

Například \(\min(\{x: x \geq 5\}) = 5\), maximum tato množina nemá, protože není shora ohraničená. Množina \(\{x: x > 0\}\) nemá v~\(\rationals\) ani minimum. Nula není prvkem této množiny a~ke každému číslu \(x > 0\) existuje číslo \(\frac{x}{2}\), které je také prvkem této množiny a~je menší.

Infimum množiny \(M\) je nejvyšší číslo menší nebo rovno všem prvkům množiny \(M\), viz rovnice~\eqref{eq:inf_definition}. Supremum množiny \(M\) je nejmenší číslo větší nebo rovno všem prvkům množiny \(M\), viz rovnice~\eqref{eq:sup_definition}. 

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'inf_definition',
		declare_variable(M, 'M', Sets,
			equal(
				inf(M),
				max(
					set_by(X, 'x', Numbers, 
						forall_in(ME, 'm', M, Numbers,
							less_or_equal(X, ME)
						)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{inf_definition}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'sup_definition',
		declare_variable(M, 'M', Sets,
			equal(
				sup(M),
				min(
					set_by(X, 'x', Numbers, 
						forall_in(ME, 'm', M, Numbers,
							greater_or_equal(X, ME)
						)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{sup_definition}
\end{fact}

Prozkoumejme vztah mezi infimem a~minimem. Nejdříve srovnejme větu~\eqref{eq:min_definition_2} a~množinu v~definici~\eqref{eq:inf_definition}. Množina obsahuje všechna čísla, která jsou menší nebo rovna všem prvkům množiny \(M\). Minimum je menší nebo rovno všem prvkům množiny \(M\). Proto, pokud existuje minimum množiny \(M\), musí platit:

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'inf_max_proof_1',
		declare_variable(M, 'M', Sets,
			in(
				min(M),
				set_by(X, 'x', Numbers, 
					forall_in(ME, 'm', M, Numbers,
						less_or_equal(X, ME)
					)				
				)
			)
		)
	).
\end{prolog}
\eeq{inf_max_proof_1}

Zároveň toto minimum je nejvyšší prvek uvedené množiny, protože všechny její prvky jsou menší nebo rovny jakémukoli prvku množiny \(M\), tedy také jejímu minimu. Proto, pokud existuje minimum množiny \(M\), platí:

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonempty_sets(Sets),
	print_validated_formula(
		'inf_max_proof_2',
		declare_variable(M, 'M', Sets,
			equal([
				inf(M),
				max(
					set_by(X, 'x', Numbers, 
						forall_in(ME, 'm', M, Numbers,
							less_or_equal(X, ME)
						)
					)
				),
				min(M)
			])
		)
	).
\end{prolog}
\eeq{inf_max_proof_2}

Infimum je tedy zobecnění pojmu minumum, obdobně supremum je zobecnění pojmu maximum.

Množinu nazveme shora ohraničenou, pokud existuje číslo větší nebo rovno všem prvkům množiny. Obdobně množinu nazveme zdola ohraničenou pokud existuje číslo menší nebo rovno všem prvkům množiny.

\section{Reálná čísla}

Uvažujme dvě různá racionální čísla \(a\) a~\(b\). Mezi nimi existuje nekonečně mnoho jiných racionálních čísel, například čísel ve tvaru \(a + \frac{b - a}{k}\). Také vidíme, že k~libovolnému racionálnímu číslu \(a\) můžeme nalézt libovolně blízké číslo \(a \pm \frac{1}{k}\), stačí zvolit dostatečně velké \(k\). Racionální čísla jsou tedy nekonečně hustá, přesto ale mají mezery. Například uhlopříčka čtverce o~straně délky 1 má délku \(\sqrt{2}\). Číslo \(\sqrt{2}\) ale není racionální. Vidíme tedy, že ani racionální čísla nám nedostačují pro popis objektů reálného světa.

Uvažujme množinu \(\{x: x^3 < 2\}\). Tato množina nemá v~oboru racionálních čísel supremum, protože neexistuje racionální číslo splňující rovnici \(\left( \frac{a}{b} \right)^3 = \frac{a^3}{b^3} = 2\). Později uvidíme, že tuto podmínku splňuje číslo \(\sqrt[3]{2}\). Množina racionálních čísel je rozdělena na dvě podmnožiny \(M\) a~\(V\), jak vidíme na obrázku~\ref{img:real_numbers_example}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}

\drawinfopenset{-4.2}{0.5}{0}{0.5};
\draw (-2, 0.5) node[anchor=south]{\(M = \{x: x^3 < 2\}\)};

\drawopeninfset{0}{1}{4.2}{1};
\draw (2, 1) node[anchor=south]{\(V = \{x: x^3 \geq 2\}\)};

\draw (0, -0.2) -- (0, 0.2);
\draw (0, -0.2) node[anchor=north]{\(\sqrt[3]{2}\)};

\draw[->] (-4.5, 0) -- (4.5, 0);
\draw (4.5, 0) node[anchor=north]{\(x\)};
\end{tikzpicture}
\caption{Příklad reálného čísla}
\label{img:real_numbers_example}
\end{figure}

Množina racionálních čísel je rozdělena na dvě množiny tak, že všechna čísla z~množiny \(M\) jsou menší než všechna čísla z~množiny \(V\), jak udávají podmínky~\eqref{eq:real_1} až~\eqref{eq:real_4}. Supremum množiny \(M\) potažmo infimum množiny \(V\) nazveme reálným číslem.

\begin{equation}
\label{eq:real_1}
M \cup V = \rationals
\end{equation}
%%%%%%%%%%%%%%%%
\begin{equation}
\label{eq:real_2}
\forall m \in M \ \forall v \in V \ m < v
\end{equation}
%%%%%%%%%%%%%%%%
\begin{equation}
\label{eq:real_3}
M \neq \emptyset
\end{equation}
%%%%%%%%%%%%%%%%
\begin{equation}
\label{eq:real_4}
V \neq \emptyset
\end{equation}

Dále si všimněme, že z~podmínky~\eqref{eq:real_1} plyne

\begin{equation}
V = \rationals \setminus M
\end{equation}

a~proto můžeme podmínku~\eqref{eq:real_2} upravit

\begin{equation}
\forall m \in M \ \forall v \in (\rationals \setminus M) \ m < v
\end{equation}
%%%%%%%%%%%%%%%%
\begin{equation}
\forall m \in M \ \forall v \in \rationals \ v \notin M \impl m < v
\end{equation}
%%%%%%%%%%%%%%%%
\begin{equation}
\forall m \in M \ \forall v \in \rationals \ v \leq m \impl v \in M
\end{equation}
%%%%%%%%%%%%%%%%
\begin{equation}
\forall m \in M \ \forall v \in (-\infty; m \rangle \ v \in M
\end{equation}
%%%%%%%%%%%%%%%%
\begin{equation}
\label{eq:real_single_set}
\forall m \in M \ (-\infty; m \rangle \subset M
\end{equation}

Neboli pokud je nějaké číslo prvkem množiny \(M\), pak jsou i~všechna menší čísla prvkem této množiny. Podmínka~\eqref{eq:real_single_set} je ekvivalentní podmínkám~\eqref{eq:real_1} a~\eqref{eq:real_2}.

Povšimněme si, že každou shora ohraničenou množinu \(M'\) můžeme rozšířit tak, aby splňovala podmínku~\eqref{eq:real_single_set} aniž bychom změnili její supremum:

\begin{equation}
M = \{x: x \in \rationals \land \exists y \in M' \ x \leq y\} 
\end{equation}

Proto platí, že každá shora ohraničená množina racionálních čísel má v~oboru reálných čísel supremum. Obdobně, každá zdola ohraničená množina racionálních čísel má v~oboru reálných čísel infimum. Reálná čísla můžeme proto definovat jako supremum podmnožiny racionálních čísel:

\begin{fact}
\begin{equation}
r \in \real \equivalent \exists M \ M \subset \rationals \land r = \sup(M)
\end{equation}
\end{fact}

Každé racionální číslo tedy zapsat ve tvaru

\begin{equation}
\forall x \in Q \ x = \sup(\{y: y \leq x\})
\end{equation}

a~proto \(\rationals \subset \real\).

Zabývejme se otázkou, zda má množina reálných čísel mezery. Mějme množinu \(M \subset \real\). Každé reálné číslo v~této množině je supremem nějaké množiny racionálních čísel. Označme množinu těchto množin \(S\), tedy

\begin{equation}
M = \{m: \exists s \in S \ m = \sup(s)\}
\end{equation}
 
Označme \(T\) sjednocení všech množin z~množiny \(S\), tedy

\begin{equation}
T = \bigcup S = \{t: \exists s \in S \ t \ \in  s\}
\end{equation}

Dále je zřejmé, že \(\sup(M) = \sup(T)\). Ale \(T\) je množina racionálnách čísel, proto pokud je \(T\) shora ohraničená množina, pak \(\sup(T)\) je reálné číslo. Obdobné úvahy lze udělat i~pro infimum. Závěrem tedy můžeme říci:

\begin{fact}
Každá shora ohraničená množina reálných čísel má v~\(\real\) supremum.

Každá zdola ohraničená množina reálných čísel má v~\(\real\) infimum.
\end{fact}

Mohli bychom definovat, jak provádět operace s~reálnými čísly pomocí manipulace s~množinami. Byla by to ale čistě teoretická definice, nikdo takto s~reálnými čísly nepočítá. Reálná čísla ale můžeme aproximovat pomocí racionálních čísel nebo pomocí desetinného rozvoje.

Uvažujme tedy reálné číslo definované jako supremum množiny \(M\) splňující podmínku~\eqref{eq:real_single_set}. V~ní uvažujme racionální čísla ve tvaru \(\frac{a}{b}\), kde \(b\) je pevně zvolený kladný jmenovatel. Potom existuje nejvyšší čitatel \(a\), respektive nejvyšší racionální číslo \(\frac{a}{b}\) se zvoleným jmenovatelem. Podle podmínky~\eqref{eq:real_single_set} musí být všechna menší racionální čísla se zvoleným jmenovatelem také obsažena v~množině \(M\). Takto jsme schopni aproximovat reálné číslo pomocí racionálního. Uvažujme dále pouze tzv. desetinné zlomky, tedy racionální čísla ve tvaru \(\frac{a}{10^n}\).

\begin{table}[ht]
\centering
\begin{tabular}{|r|l|l|l|}
\hline
n & a & \(\frac{a}{10^n}\) & desetinné číslo\\
\hline
0 & 1 & \(\frac{1}{1}\) & 1 \\
1 & 12 & \(\frac{12}{10}\) & 1.2 \\
2 & 125 & \(\frac{125}{100}\) & 1.25 \\
3 & 1259 & \(\frac{1259}{1000}\) & 1.259 \\
4 & 12599 & \(\frac{12599}{10000}\) & 1.2599 \\
\ldots & \ldots & \ldots & \ldots \\
\hline
\end{tabular}
\caption{Desetinný rozvoj reálného čísla \(\sqrt[3]{2}\)}
\label{tab:real_decimal}
\end{table}

Takovýto tzv. nekonečný desetinný rozvoj je podle výše uvedeného postupu plně určen reálným číslem. Prozkoumejme, zda to platí i~naopak a~zda je reálné číslo plně určeno jeho desetinným rozvojem. Označme množinu všech čísel v~desetinném rozvoji \(S\), v~našem příkladu proto bude platit \(S = \{1, 1.2, 1.25, 1.259, 1.2599, ...\}\). Je zřejmé, že \(S \subset M\) a~proto \(\sup(S) \leq \sup(M)\).

Předpokládejme, že \(\sup(S) < \sup(M)\). Potom \(\exists x \in M \ x > \sup(S)\). Označme rozdíl \(\mathrm{d}x = x - \sup(S)\). Potom ale \(\exists n \in \naturalnumbers \ \mathrm{d}x > \frac{1}{10^n}\). To znamená, že se desetinný rozvoj musí lišit na \(n\)-tém místě za desetinnou čárkou, protože tuto číslici můžeme zvýšit alespoň o~jedničku. Tím jsme ale dospěli ke sporu. Znamená to tedy, že nemůže platit \(\sup(S) < \sup(M)\) a~platí \(\sup(S) = \sup(M)\). Reálné číslo je tedy plně určeno svým (nekonečným) desetinným rozvojem. Pokud čtěnář zná pojem limity posloupnosti, pak jsme právě dokázali, že každé reálné číslo je rovno limitě posloupnosti svého desetinného rozvoje. 

Desetinný rozvoj nám umožňuje s~reálnými čísly počítat. Samozřejmě počítáme s~konečným počtem desetinných míst a~musíme pak mít na paměti, že počítáme pouze přibližně.

Rozšiřme definici mocniny na reálná čísla. Nejprve rozšiřme definice~\eqref{eq:rational_power_by_one} a~\eqref{eq:rational_power_distributivity} na reálné základy. Získáme tak definice~\eqref{eq:real_power_by_one_def} a~\eqref{eq:real_power_distributivity_def}.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_power_by_one_def',
		forall_in(A, 'a', real_numbers, Values,
			equal([A^1, A])
		)
	).				
\end{prolog}
\eeq{real_power_by_one_def}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_power_distributivity_def',
		forall_in(A, 'a', difference(real_numbers, set_of([0])), Values,
			forall_in([B, C], ['b', 'c'], integers, Values,
				equal([A^(B + C), A^B * A^C])
			)
		)
	).				
\end{prolog}
\eeq{real_power_distributivity_def}
\end{fact}

Definujme odmocňování jako inverzní funkci k~umocňování. Musíme se ale omezit na kladné hodnoty základu:

\begin{prolog}
?-	print_validated_formula(
		'sqrt_def',
		forall_in([A, C], ['a', 'c'], positive_real_numbers, [1, 2, 3, 4, 9, 8, 27],
			forall_in(B, 'b', natural_numbers, [1, 2, 3],
				equiv(
					equal(C, A^B),
					equal(A, sqrt(B, C))
				)
			)
		)
	).				
\end{prolog}
\eeq{sqrt_def}

Dosazením jednoho vztahu do druhého získáme identity~\eqref{eq:sqrt_inv_1_proof} a~\eqref{eq:sqrt_inv_2_proof}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'sqrt_inv_1_proof',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', natural_numbers, Numbers,
				equal(sqrt(B, A)^B, A)
			)
		)
	).				
\end{prolog}
\eeq{sqrt_inv_1_proof}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'sqrt_inv_2_proof',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', natural_numbers, Numbers,
				equal(sqrt(B, A^B), A)
			)
		)
	).				
\end{prolog}
\eeq{sqrt_inv_2_proof}

Zkusme dále rozšířit exponent na racionální čísla. Začněme identitou~\eqref{eq:sqrt_rational_proof}.

\begin{prolog}
?-	make_test_positive_numbers(Bases),
	make_test_natural_numbers(Exponents),
	print_validated_formula(
		'sqrt_rational_proof',
		declare_variable(A, 'a', Bases,
			declare_variable(B, 'b', Exponents,
				equal([
					A,
					A^1,
					A^(B / B),
					(A^(1 / B))^B
				])
			)
		)
	).				
\end{prolog}
\eeq{sqrt_rational_proof}

Srovnáním vztahů~\eqref{eq:sqrt_rational_proof} a~\eqref{eq:sqrt_inv_1_proof} vidíme, že platí vztahy~\eqref{eq:pow_rational_1_proof} a~\eqref{eq:pow_rational_2_proof}. Tím jsme definovali umocňování pro racionální exponent.

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'pow_rational_1_proof',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', natural_numbers, Numbers,
				equal(A^(1 / B), sqrt(B, A))
			)
		)
	).				
\end{prolog}
\eeq{pow_rational_1_proof}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'pow_rational_2_proof',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', integers, Numbers,
				forall_in(C, 'c', natural_numbers, Numbers,
					equal([
						A^(B / C),
						(sqrt(C, A)^B),
						sqrt(C, A^B)
					])
				)
			)
		)
	).				
\end{prolog}
\eeq{pow_rational_2_proof}

Protože umocňování není komutativní operace, tak můžeme definovat ještě jinou inverzní operaci, a~to logaritmus.

\begin{prolog}
?-	print_validated_formula(
		'log_def',
		forall_in(A, 'a', difference(positive_real_numbers, set_of([1])), [2, 3],
			forall_in(B, 'b', real_numbers, [1, 2, 3],
				forall_in(C, 'c', positive_real_numbers, [1, 2, 3, 4, 9, 8, 27],
					equiv(
						equal(C, A^B),
						equal(B, log(A, C))
					)
				)
			)
		)
	).				
\end{prolog}
\eeq{log_def}

Říkáme, že \(b\) je logaritmem o~základu \(a\) z~argumentu \(c\). Základ logaritmu musí být kladný a~nesmí být roven 1. Argument logaritmu musí být kladný. V~dalších úvahách budeme vždy předpokládat, že jsou tyto předpoklady splněny.

Dosazením jednoho vztahu do druhého získáme identity~\eqref{eq:log_inv_1} a~\eqref{eq:log_inv_2}.

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'log_inv_1',
		forall_in(A, 'a', difference(positive_real_numbers, set_of([1])), Numbers,
			forall_in(B, 'b', real_numbers, Numbers,
				equal(log(A, A^B), B)
			)
		)
	).				
\end{prolog}
\eeq{log_inv_1}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'log_inv_2',
		forall_in(A, 'a', difference(positive_real_numbers, set_of([1])), Numbers,
			forall_in(B, 'b', positive_real_numbers, Numbers,
				equal(A^log(A, B), B)
			)
		)
	).				
\end{prolog}
\eeq{log_inv_2}
\end{fact}

Odvoďme vztah pro logaritmus součinu. Při odvození využijeme identitu~\eqref{eq:log_inv_2}. Dále využijeme fakt, že pro \(a \neq 1\) je funkce \(a^x\) prostá, tedy různým argumentům \(x\) přiřazuje různé hodnoty \(a^x\). Proto z~\(a^x = a^y\) plyne \(x = y\).

\begin{prolog}
?-	make_test_positive_numbers(Numbers),
	make_test_log_bases(Bases),
	print_validated_formula(
		'log_product_proof',
		declare_variable(A, 'a', Bases,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					proof(
					[],
					[
						equal(B * C, B * C),
						equal(A^log(A, B * C), A^log(A, B) * A^log(A, C)),
						equal(A^log(A, B * C), A^(log(A, B) + log(A, C))),
						equal(log(A, B * C), log(A, B) + log(A, C))
					])
				)
			)
		)
	).				
\end{prolog}
\eeq{log_product_proof}

Obdobně můžeme odvodit vztah pro logaritmus podílu.

\begin{prolog}
?-	make_test_positive_numbers(Numbers),
	make_test_log_bases(Bases),
	print_validated_formula(
		'log_fraction_proof',
		declare_variable(A, 'a', Bases,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					proof(
					[],
					[
						equal(B / C, B / C),
						equal(A^log(A, B / C), A^log(A, B) / A^log(A, C)),
						equal(A^log(A, B / C), A^(log(A, B) - log(A, C))),
						equal(log(A, B / C), log(A, B) - log(A, C))
					])
				)
			)
		)
	).				
\end{prolog}
\eeq{log_fraction_proof}

Dále odvoďme vztah pro logaritmus mocniny.

\begin{prolog}
?-	make_test_log_bases(Bases),
	make_test_numbers(Exponents),
	make_test_positive_numbers(Numbers),
	print_validated_formula(
		'log_power_proof',
		declare_variable(A, 'a', Bases,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Exponents,
					proof(
					[],
					[
						equal(B^C, B^C),
						equal(B^C, (A^log(A, B))^C),
						equal(A^log(A, B^C), A^(C * log(A, B))),
						equal(log(A, B^C), C * log(A, B))
					])
				)
			)
		)
	).				
\end{prolog}
\eeq{log_power_proof}

Vidíme, že logaritmus snižuje \uv{řád operace}. Z~umocňování dělá násobení a~z~násobení a~dělení dělá sčítání a~odčítání. Nakonec odvoďme vztah mezi logaritmy různých základů.

\begin{prolog}
?-	make_test_log_bases(Bases),
	make_test_positive_numbers(Numbers),
	print_validated_formula(
		'log_base_proof',
		declare_variable(A, 'a', Bases,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Bases,
					proof(
					[],
					[
						equal(B, B),
						equal(A^log(A, B), B),
						equal(log(C, A^log(A, B)), log(C, B)),
						equal(log(A, B) * log(C, A), log(C, B)),
						equal(log(A, B), log(C, B) / log(C, A))
					])
				)
			)
		)
	).				
\end{prolog}
\eeq{log_base_proof}


\begin{fact}
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_numbers_add_comutativity',
		forall_in([A, B], ['a', 'b'], real_numbers, Values,
			equal([A + B, B + A])
		)
	).
\end{prolog}
\eeq{real_numbers_add_comutativity}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_numbers_add_asociativity',
		forall_in([A, B, C], ['a', 'b', 'c'], real_numbers, Values,
			equal([par(A + B) + C, A + par(B + C)])
		)
	).
\end{prolog}
\eeq{real_numbers_add_asociativity}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_multiply_by_one',
		forall_in(A, 'a', real_numbers, Values,
			equal([A * 1, A])
		)
	).				
\end{prolog}
\eeq{real_multiply_by_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_multiplication_distributivity',
		forall_in([A, B, C], ['a', 'b', 'c'], real_numbers, Values,
			equal([A * (B + C), A * B + A * C])
		)
	).				
\end{prolog}
\eeq{real_multiplication_distributivity}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_multiplication_comutativity',
		forall_in([A, B], ['a', 'b'], real_numbers, Values,
			equal([A * B, B * A])
		)
	).				
\end{prolog}
\eeq{real_multiplication_comutativity}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_multiplication_asociativity',
		forall_in([A, B, C], ['a', 'b', 'c'], real_numbers, Values,
			equal([par(A * B) * C, A * par(B * C)])
		)
	).				
\end{prolog}
\eeq{real_multiplication_asociativity}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_power_by_one',
		forall_in(A, 'a', real_numbers, Values,
			equal([A^1, A])
		)
	).				
\end{prolog}
\eeq{real_power_by_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_power_distributivity',
		forall_in(A, 'a', positive_real_numbers, Values,
			forall_in([B, C], ['b', 'c'], real_numbers, Values,
				equal([A^(B + C), A^B * A^C])
			)
		)
	).				
\end{prolog}
\eeq{real_power_distributivity}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_power_by_multiplication',
		forall_in(A, 'a', positive_real_numbers, Values,
			forall_in([B, C], ['b', 'c'], real_numbers, Values,
				equal([(A^B)^C, A^(B * C)])
			)
		)
	).
\end{prolog}
\eeq{real_power_by_multiplication}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'real_power_of_multiplication',
		forall_in([A, B], ['a', 'b'], positive_real_numbers, Values,
			forall_in(C, 'c', real_numbers, Values,
				equal((A*B)^C, A^C * B^C)
			)
		)
	).
\end{prolog}
\eeq{real_power_of_multiplication}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'real_fraction_one',
		forall_in(A, 'a', difference(real_numbers, set_of([0])), Numbers,
			equal([A / A, 1])
		)
	).
\end{prolog}
\eeq{real_fraction_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'real_reduction',
		forall_in(A, 'a', real_numbers, Numbers,
			forall_in([B, C], ['b', 'c'], difference(real_numbers, set_of([0])), Numbers,
				equal(A / B, (A * C) / (B * C))
			)
		)
	).
\end{prolog}
\eeq{real_reduction}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'real_division_distributivity',
		declare_plus_minus(PM,
			forall_in([A, B], ['a', 'b'], real_numbers, Numbers,
				forall_in(C, 'c', difference(real_numbers, set_of([0])), Numbers,
					equal(plus_minus(A, B, PM) / C, plus_minus(A / C, B / C, PM))
				)
			)
		)
	).
\end{prolog}
\eeq{real_division_distributivity}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'sum_of_fractions',
		declare_plus_minus(PM,
			forall_in([A, C], ['a', 'c'], real_numbers, Numbers,
				forall_in([B, D], ['b', 'd'], difference(real_numbers, set_of([0])), Numbers,
					equal(
						plus_minus(A / B, C / D, PM),
						plus_minus(A * D, B * C, PM) / (B * D)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{sum_of_fractions}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'real_division_of_rationals',
		forall_in(A, 'a', real_numbers, Numbers,
			forall_in([B, C, D], ['b', 'c', 'd'], difference(real_numbers, set_of([0])), Numbers,
				equal((A / B) / (C / D), (A * D) / (B * C))
			)
		)
	).
\end{prolog}
\eeq{real_division_of_rationals}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'real_power_by_negative_exponent_2',
		forall_in(A, 'a', difference(positive_real_numbers, set_of([0])), Numbers,
			forall_in(B, 'b', real_numbers, Numbers,
				equal([A^(-B), 1 / (A^B)])
			)
		)
	).
\end{prolog}
\eeq{real_power_by_negative_exponent_2}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'real_power_by_negative_exponent',
		forall_in(A, 'a', difference(real_numbers, set_of([0])), Numbers,
			equal([A^(-1), 1 / A])
		)
	).
\end{prolog}
\eeq{real_power_by_negative_exponent}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'sqrt_inv_1',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', natural_numbers, Numbers,
				equal(sqrt(B, A)^B, A)
			)
		)
	).				
\end{prolog}
\eeq{sqrt_inv_1}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'sqrt_inv_2',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', natural_numbers, Numbers,
				equal(sqrt(B, A^B), A)
			)
		)
	).				
\end{prolog}
\eeq{sqrt_inv_2}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'pow_rational_1',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', natural_numbers, Numbers,
				equal(A^(1 / B), sqrt(B, A))
			)
		)
	).				
\end{prolog}
\eeq{pow_rational_1}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'pow_rational_2',
		forall_in(A, 'a', positive_real_numbers, Numbers,
			forall_in(B, 'b', integers, Numbers,
				forall_in(C, 'c', natural_numbers, Numbers,
					equal([
						A^(B / C),
						(sqrt(C, A)^B),
						sqrt(C, A^B)
					])
				)
			)
		)
	).				
\end{prolog}
\eeq{pow_rational_2}
%%%%%%%%%%%%%%%%%%%%%%%
\eeq{log_inv_1}
\eeq{log_inv_2}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'log_product',
		forall_in(A, 'a', difference(positive_real_numbers, set_of([1])), Numbers,
			forall_in([B, C], ['b', 'c'], positive_real_numbers, Numbers,
				equal(log(A, B * C), log(A, B) + log(A, C))
			)
		)
	).				
\end{prolog}
\eeq{log_product}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'log_fraction',
		forall_in(A, 'a', difference(positive_real_numbers, set_of([1])), Numbers,
			forall_in([B, C], ['b', 'c'], positive_real_numbers, Numbers,
				equal(log(A, B / C), log(A, B) - log(A, C))
			)
		)
	).				
\end{prolog}
\eeq{log_fraction}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'log_power',
		forall_in(A, 'a', difference(positive_real_numbers, set_of([1])), Numbers,
			forall_in(B, 'b', positive_real_numbers, Numbers, 
				forall_in(C, 'c', real_numbers, Numbers,
					equal(log(A, B^C), C * log(A, B))
				)
			)
		)
	).
\end{prolog}
\eeq{log_power}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'log_base',
		forall_in([A, C], ['a', 'c'], difference(positive_real_numbers, set_of([1])), Numbers,
			forall_in(B, 'b', positive_real_numbers, Numbers,
				equal(log(A, B), log(C, B) / log(C, A))
			)
		)
	).				
\end{prolog}
\eeq{log_base}
\end{fact}
