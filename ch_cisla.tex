\chapter{Čísla}

\begin{prolog}
:- ensure_loaded("../equations/formula").
:- ensure_loaded("../equations/truth_table").

make_test_numbers([-1, 0, 1, 2, 3, 1.5]).
make_test_nonzero_numbers([-1, 1, 2, 3, 1.5]).
make_test_integers([-3, -2, -1, 0, 1, 2, 3]).
make_test_nonzero_integers([-3, -2, -1, 1, 2, 3]).
make_test_natural_numbers([1, 2, 3, 4, 5]).
make_test_predicates(Y, [equal([Y, 1]), equal([Y, 2]), log_true, log_false]).
\end{prolog}


\begin{abstract}
V~této kapitole definujeme obory čísel a~prozkoumáme jejich vlastnosti.
\end{abstract}

\section{Přirozená čísla}

Začněme nějjednoduššími tzv. přirozenými čísly. Přirozenými čísly rozumíme čísla 1, 2, 3 atd. Upozorňuji, že literatura není jednotná v~tom, zda je nula přirozené číslo. V~této knize nulu nepovažujeme za přirozené číslo. Přirozená čísla typicky vyjadřují počet nějakých objektů. Množinu všech přirozených čísel značíme \(\naturalnumbers\). Tato množina je nekonečná, neexistuje největší přirozené číslo.

Prozkoumejme, jak můžeme přirozená čísla definovat. Nejnižší přirozené číslo je 1. Každé přirozené číslo \(n\) má
následníka, označme ho \(n + 1\). Každé přirozené číslo, vyjma čísla 1, je následníkem právě jednoho čísla. To nás vede k~axiomům~\eqref{eq:natural_numbers_definition_1} až~\eqref{eq:natural_numbers_definition_4}.

\begin{fact}
\begin{prolog}
?-	print_validated_formula(
		'natural_numbers_definition_1',
		in(1, natural_numbers)
	).
\end{prolog}
\eeq{natural_numbers_definition_1}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_definition_2',
		forall_in(N, 'n', natural_numbers, Values,
				in(N + 1, natural_numbers)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_2}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_definition_3',
		forall_in(M, 'm', natural_numbers, Values,
			forall_in(N, 'n', natural_numbers, Values,
				equiv(
					equal([M, N]),				
					equal([M + 1, N + 1])
				)
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_3}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'natural_numbers_definition_4',
		not(
			exists_in(N, 'n', natural_numbers, Values,
				equal([N + 1, 1])
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_4}
%%%%%%%%%%%%%%%%%%%%%
Pro každý predikát \(\predicate{A}(n)\) platí:
\begin{prolog}
?-	make_test_numbers(Values),
	make_test_predicates(Z, Predicates),
	print_validated_formula(
		'natural_numbers_definition_induction',
		declare_predicate(A, 'A', Predicates,
			impl(			
				and(
					apply(A, [Z], [1]),
					forall_in(N, 'n', natural_numbers, Values,
						impl(
							apply(A, [Z], [N]),
							apply(A, [Z], [N + 1])
						)
					)
				),
				forall_in(N, 'n', natural_numbers, Values,
					apply(A, [Z], [N])
				)
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_definition_induction}
\end{fact}

Číslo 2 tedy můžeme zapsat jako \(1 + 1\), číslo 3 jako \(2 + 1 = (1 + 1) + 1\) atd. Zápis a~význam přirozených čísel nám shrnuje tabulka~\ref{tab:natural_numbers}. Vidíme, že počet jedniček v~zápisu odpovídá počtu reprezentovaných objektů.

\begin{table}[ht]
\centering
\begin{tabular}{|r|l|l|l|}
\hline
Číslo & Pořadí & Reprezentace & Význam \\
\hline
1 & 1 & 1 & \(\bigcirc\) \\
2 & 1 + 1 & 1 + 1 & \(\bigcirc \bigcirc\) \\
3 & 2 + 1 & (1 + 1) + 1 & \(\bigcirc \bigcirc \bigcirc\) \\
4 & 3 + 1 & ((1 + 1) + 1) + 1 & \(\bigcirc \bigcirc \bigcirc \bigcirc\) \\
\ldots & \ldots & \ldots & \ldots \\
\hline
\end{tabular}
\caption{Přirozená čísla}
\label{tab:natural_numbers}
\end{table}

Fakt, že každé přirozené číslo kromě jedničky je následník jiného přirozeného čísla, nám umožňuje zavést důkaz matematickou indukcí. Máme-li predikát \(\predicate{A}(n)\), který je pravdivý pro \(n=1\) a~z~jeho pravdivosti pro \(n\) plyne  pravdivost pro \(n + 1\), pak je tento predikát pravdivý pro všechna přirozená čísla. Důkaz matematickou
indukcí popisuje vztah~\eqref{eq:natural_numbers_definition_induction}.

Intuitivně je princip důkazu matematickou indukcí zřejmý. Víme, že predikát \(\predicate{A}(n)\) je pravdivý pro \(n=1\). Z~jeho pravdivosti pro \(n=1\) plyne pravdivost pro \(n=2\), z~ní pak pro \(n=3\) atd. Jedná se vlastně o~tranzitivitu implikace prodlouženou do nekonečna.

Aximom~\eqref{eq:natural_numbers_definition_induction} má ještě jeden význam. Axiomy~\eqref{eq:natural_numbers_definition_1} až~\eqref{eq:natural_numbers_definition_4} nám definují, že existují přirozená čísla mající strukturu podle tabulky~\ref{tab:natural_numbers}. Nezaručují nám ale, že existují pouze takováto přirozená čísla. To nám zaručuje právě axiom~\eqref{eq:natural_numbers_definition_induction}, stačí zvolit \(\predicate{A}(n) = \) \uv{\(n\) lze vyjádřit postupným přičítáním 1 k~číslu 1}. Tento predikát je pravdivý pro každé přirozené číslo, které odpovídá tabulce ~\ref{tab:natural_numbers}, ale pouze pro ně. Zkuste ho dokázat matematickou indukcí. Z~toho ale vyplývá, že množina přirozených čísel nemůže obsahovat čísla nesplňující tento predikát, protože jinak by axiom~\eqref{eq:natural_numbers_definition_induction} udával, že predikát je pravdivý i~pro tato čísla. Tím bychom získali spor.

Přirozená čísla lze také znázornit na číselné ose, jak je zobrazeno na obrázku~\ref{img:ciselna_osa}. Osa začíná číslem 1 a~pokračuje do nekonečna.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{0}{4}	
\end{tikzpicture}
\caption{Číselná osa}
\label{img:ciselna_osa}
\end{figure}

Nyní, když už víme, co jsou přirozená čísla, tak si zkusme definovat jejich součet. Jak se sčítají přirozená čísla všichni víme od~první třídy základní školy. Chceme-li sečíst čísla \(a\) a~\(b\), pak k~číslu \(a\) \(b\)-krát přičteme jedničku:

\begin{equation}
\label{eq:soucet_n_definice}
c = a + b = a + \overbrace{1 + 1 + 1 + ...}^{b \times}
\end{equation}

Povšimněme si, že výraz pod složenou závorkou odpovídá reprezentaci čísla \(b\) až na pořadí přičítání jedniček. Proto pokud bychom tento vztah rozepsali pomocí zavedené reprezentace přirozených čísel, tak by \uv{počet jedniček} v~jednotlivých částech rovnice~\eqref{eq:soucet_n_definice} byl stejný, pouze by byli jinak uzávorkované. Například pro \(a=2\), \(b=3\) bychom dostali:

\begin{prolog}
?-	print_validated_formula(
		'add_example',
		equal(
			[
				2 + 3,
				par(1 + 1) + par(par(1 + 1) + 1),
				linebreak,
				par(par(par(1 + 1) + 1) + 1) + 1,
				5
			]
		)
	).
\end{prolog}
\eeq{add_example}

To je logické, součet má představovat počet objektů, které ze dvou skupin dáme dohromady. Přesunutím objektů do jedné skupiny se tyto objekty nemohou vytvořit nebo ztratit. Každý objekt je reprezentován jednou jedničkou, proto se tyto jedničky mohou pouze přeskupovat, ale jejich počet se nemůže změnit. Se součtem, popřípadě součty, můžeme proto provádět takové operace, které nezmění počet jedniček ve výrazu s~reprezentacemi přirozených čísel. Máme dvě takovéto operace. Můžeme prohodit operandy součtu beze změny jeho hodnoty. Tato vlastnost se nazývá komutativita sčítání a~popisuje ji rovnice~\eqref{eq:natural_numbers_comutativity}. Dále můžeme změnit uzávorkování součtů beze změny celkového součtu. Tato vlastnost se nazývá asociativita sčítání a~popisuje ji rovnice~\eqref{eq:natural_numbers_asociativity}.

\begin{fact}
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'natural_numbers_comutativity',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				equal([A + B, B + A])
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_comutativity}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'natural_numbers_asociativity',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				forall_in(C, 'c', natural_numbers, Values,
					equal([par(A + B) + C, A + par(B + C)])
				)
			)
		)
	).
\end{prolog}
\eeq{natural_numbers_asociativity}
\end{fact}

Nyní můžeme zapomenout na původní definici součtu pomocí přičítání jedniček. Rovnice~\eqref{eq:natural_numbers_comutativity} a~\eqref{eq:natural_numbers_asociativity} spolu s~definicí, jak jdou čísla po sobě~v~tabulce~\ref{tab:natural_numbers} nám plně definují součet dvou čísel. Pro každý součet dvou čísel totiž můžeme postupně snižovat jedno číslo a~zvyšovat druhé, až získáme výsledek. Ukážeme si to na příkladu součtu 5 + 3:

\begin{prolog}
?-	print_validated_formula(
		'natural_numbers_add_example',
		equal([
			5 + 3,
			5 + par(2 + 1),
			5 + par(1 + 2),
			par(5 + 1) + 2,
			linebreak,
			6 + 2,
			6 + par(1 + 1),
			par(6 + 1) + 1,
			linebreak,
			7 + 1,
			8
		])
	).
\end{prolog}
\eeq{natural_numbers_add_example}

Součet můžeme také zobrazit na číselné ose, jak je vidět na obrázku \ref{img:soucet_ciselna_osa}. Na obrázku~\ref{img:komutativita_souctu_ciselna_osa} je znázorněna komutativita součtu a~na obrázku~\ref{img:asociativita_souctu_ciselna_osa} asociativita součtu.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{0}{5}
\drawboxrow{0}{0}{2}{fill=cyan}
\drawboxrow{2}{0}{3}{fill=orange}
\end{tikzpicture}
\caption{Grafické znázornění součtu \(\textcolor{cyan}{2} + \textcolor{orange}{3}\)}
\label{img:soucet_ciselna_osa}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{2}{8}
\drawboxrow{0}{2}{5}{fill=orange}
\drawboxrow{5}{2}{3}{fill=cyan}

\drawhnaturalnumberline{0}{0}{8}
\drawboxrow{0}{0}{3}{fill=cyan}
\drawboxrow{3}{0}{5}{fill=orange}
\end{tikzpicture}
\caption{Grafické znázornění komutativity součtu \(\textcolor{orange}{5} + \textcolor{cyan}{3} = \textcolor{cyan}{3} + \textcolor{orange}{5}\)}
\label{img:komutativita_souctu_ciselna_osa}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhnaturalnumberline{0}{2.5}{9}
\drawboxrow{0}{3}{2}{fill=cyan}
\drawboxrow{2}{3}{3}{fill=orange}
\drawboxrow{5}{2.5}{4}{fill=green}

\drawhnaturalnumberline{0}{0}{9}
\drawboxrow{0}{0.5}{2}{fill=cyan}
\drawboxrow{2}{0}{3}{fill=orange}
\drawboxrow{5}{0}{4}{fill=green}
\end{tikzpicture}
\caption{Grafické znázornění asociativity součtu \((\textcolor{cyan}{2} + \textcolor{orange}{3}) + \textcolor{green}{4} = \textcolor{cyan}{2} + (\textcolor{orange}{3} + \textcolor{green}{4})\)}
\label{img:asociativita_souctu_ciselna_osa}
\end{figure}

Pokračujme definicí součinu. Chceme-li vynásobit čísla \(a\) a~\(b\), pak \(b\)-krát sečteme číslo \(a\).

\begin{equation}
\label{eq:multiplication_definition}
c = a \cdot b = \overbrace{a + a + a + ...}^{b \times}
\end{equation}

Násobení můžeme znázornit graficky pomocí obdélníka. Podle definice \eqref{eq:multiplication_definition} musíme při výpočtu součinu \(a \cdot b\) sečíst \(b\) čísel \(a\). Pokud tedy číslo \(a\) představuje \(a\) objektů a~my je vyskládáme do jedné řady, pak součin \(a \cdot b\) může být zakreslen jako \(b\) takovýchto řad nad sebou. Například součin \(3 \cdot 4\) je zobrazen na obrázku~\ref{img:multiplication_definition}. 

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawnaturalnumberplane{0}{0}{3}{4};
\drawboxrect{0}{0}{3}{4}{fill=lightgray};
\end{tikzpicture}
\caption{Grafické znázornění součinu \(3 \cdot 4\)}
\label{img:multiplication_definition}
\end{figure}

Z~definice~\eqref{eq:multiplication_definition} přímo plynou dva vztahy. Vztah \eqref{eq:natural_multiply_by_one} nám udává, co znamená násobit číslem 1. Vztah~\eqref{eq:multiplication_distributivity} je tzv. distributivita násobení a~udává vztah mezi nádobením a~sčítáním.

\begin{fact}
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'natural_multiply_by_one',
		forall_in(A, 'a', natural_numbers, Values,
			equal([A * 1, A])
		)
	).				
\end{prolog}
\eeq{natural_multiply_by_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'multiplication_distributivity',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				forall_in(C, 'c', natural_numbers, Values,
					equal([A * (B + C), A * B + A * C])
				)
			)
		)
	).				
\end{prolog}
\eeq{multiplication_distributivity}
\end{fact}

Distributivitu součinu můžeme odvodit rozepsáním součinu pomocí definice, jak je vidět v rovnici~\ref{eq:multiplication_distributivity_proof}. Graficky je distributivita znázorněna na obrázku~\ref{img:multiplication_distributivity}.

\begin{equation}
\label{eq:multiplication_distributivity_proof}
a \cdot (b + c) = \overbrace{a + a + a + ...}^{(b + c) \times} = \overbrace{a + a + a + ...}^{b \times} + \overbrace{a + a + a + ...}^{c \times} = a \cdot b + a \cdot c
\end{equation}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawnaturalnumberplane{0}{0}{4}{5};
\drawboxrect{0}{0}{4}{2}{fill=cyan};
\drawboxrect{0}{2}{4}{3}{fill=orange};
\end{tikzpicture}
\caption{Grafické znázornění distributivity součinu \(4 \cdot (\textcolor{cyan}{2} + \textcolor{orange}{3}) = 4 \cdot \textcolor{cyan}{2} + 4 \cdot \textcolor{orange}{3}\)}
\label{img:multiplication_distributivity}
\end{figure}

Zamyslíme-li se nad vztahy~\ref{eq:natural_multiply_by_one} a~\ref{eq:multiplication_distributivity}, tak zjistíme, že nám plně definují součin přirozených čísel. Pravý operand totiž můžeme postupně snižovat o~jedničku a~rozepsat součin na součet. Například pro součin \(3 \cdot 4\) získáme:

\begin{prolog}
?-	print_validated_formula(
		'multiplication_example',
		equal([
			3 * 4,
			3 * (3 + 1),
			3 * 3 + 3 * 1,
			3 * (2 + 1) + 3 * 1,
			linebreak,
			3 * 2 + 3 * 1 + 3 * 1,
			3 * (1 + 1) + 3 * 1 + 3 * 1,
			linebreak,
			3 * 1 + 3 * 1 + 3 * 1 + 3 * 1,
			3 + 3 + 3 + 3,
			12
		])
	).				
\end{prolog}
\eeq{multiplication_example}

Původní definici tedy můžeme snížit nahradit formálními rovnicemi~\ref{eq:natural_multiply_by_one} a~\ref{eq:multiplication_distributivity}.

Z~grafické reprezentace součinu je také vidět, že součin je komutativní operace. Obdélníku totiž můžeme prohodit strany, aniž by se tím změnil jeho obsah. Počet objektů, na obrázku~\ref{img:multiplication_comutativity} znázorněných počtem čtverců, se tím nezmění. Jinak řečeno, máme-li \(b\) skupin (na levém obrázku řádků) po \(a\) objektech, pak je můžeme přeskupit tak, že budeme mít \(a\) skupin po \(b\) objektech. Přeskupením se počet objektů nezmění. Komutativitu součinu popisuje rovnice~\eqref{eq:multiplication_comutativity}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawnaturalnumberplane{0}{0}{3}{4};
\drawboxrect{0}{0}{3}{4}{fill=orange};

\drawnaturalnumberplane{5}{0}{4}{3};
\drawboxrect{5}{0}{4}{3}{fill=cyan};
\end{tikzpicture}
\caption{Grafické znázornění komutativity součinu \(\textcolor{orange}{3 \cdot 4} = \textcolor{cyan}{4 \cdot 3}\)}
\label{img:multiplication_comutativity}
\end{figure}

Obdobně můžeme uvažovat o~asociativitě součinu popsaného rovnicí~\eqref{eq:multiplication_asociativity}. Výraz \(a \cdot b \cdot c\) odpovídá objemu kvádru, v~případě přirozených čísel \(a\), \(b\) a~\(c\) počtu jednotkových krychlí naskládaných do kvádru. Postavením kvádru na jinou stranu se jeho objem - počet jednotkových krychlí - nezmění. Proto součin musí být asociativní operace.

\begin{fact}
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'multiplication_comutativity',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				equal([A * B, B * A])
			)
		)
	).				
\end{prolog}
\eeq{multiplication_comutativity}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'multiplication_asociativity',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				forall_in(C, 'c', natural_numbers, Values,
					equal([par(A * B) * C, A * par(B * C)])
				)
			)
		)
	).				
\end{prolog}
\eeq{multiplication_asociativity}
\end{fact}

Nakonec rovnicí~\eqref{eq:power_definition} definujeme mocninu jako opakované násobení.

\begin{equation}
\label{eq:power_definition}
a^b = \overbrace{a \cdot a \cdot a \cdot ...}^{b \times}
\end{equation}

Opět můžeme z~této definice odvodit rovnice~\eqref{eq:natural_power_by_one} a~\eqref{eq:power_distributivity}, které nám plně definují mocniny přirozených čísel.

\begin{fact}
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'natural_power_by_one',
		forall_in(A, 'a', natural_numbers, Values,
			equal([A^1, A])
		)
	).				
\end{prolog}
\eeq{natural_power_by_one}
%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_distributivity',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				forall_in(C, 'c', natural_numbers, Values,
					equal([A^(B + C), A^B * A^C])
				)
			)
		)
	).				
\end{prolog}
\eeq{power_distributivity}
\end{fact}

Na rozdíl od sčítání a~násobení není umocňování komutativní operace (\(2^3 = 8 \neq 3^2 = 9\)) ani asociativní operace (\((4^3)^2 = 4096 \neq 4^{(3^2)} = 262144\)). Nicméně některé zákonitosti zde platí. Dokážeme rovnici~\eqref{eq:power_by_multiplication_proof}.

\begin{fact}
\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				forall_in(C, 'c', natural_numbers, Values,
					equal([(A^B)^C, A^(B * C)])
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof}
\end{fact}

Mocniny bohužel není možné jednoduše graficky znázornit jako násobení nebo sčítání. Rovnici proto dokážeme matematickou indukcí. Nejdříve ověříme platnost rovnice pro \(c = 1\):

\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof_1',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				equal([(A^B)^1, A^B, A^(B * 1)])
			)
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof_1}

Dále ověříme platnost výroku~\eqref{eq:power_by_multiplication_proof_2} a~to pomocí rovnice~\eqref{eq:power_by_multiplication_proof_3}.

\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof_2',
		forall_in(A, 'a', natural_numbers, Values,
			forall_in(B, 'b', natural_numbers, Values,
				forall_in(C, 'c', natural_numbers, Values,
					impl(
						equal([(A^B)^C, 	A^(B*C)]),
						equal([(A^B)^(C+1), 	A^(B*(C+1))])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof_2}

V~prvním kroku jsme využili distributivitu násobení. Ve druhém kroku jsme využili předpoklad z~výroku~\eqref{eq:power_by_multiplication_proof_2}. Nakonec jsme opět využili distributivitu násobení, tentokrát opačným směrem, a~upravili exponent do požadovaného tvaru. Tím je rovnice~\eqref{eq:power_by_multiplication_proof} dokázána pro všechna přirozená čísla.

\begin{prolog}
?-	make_test_natural_numbers(Values),
	print_validated_formula(
		'power_by_multiplication_proof_3',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				declare_variable(C, 'c', Values,
					equal([
						(A^B)^(C + 1),
						(A^B)^C * (A^B)^1,
						A^(B*C) * A^B,
						A^(B*C + B),
						A^(B*(C+1))
					])
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_multiplication_proof_3}

\section{Celá čísla}

Zkusme dále definovat rozdíl jako opačnou operaci k~součtu pomocí rovnice~\eqref{eq:difference_definition}.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'difference_definition',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				declare_variable(C, 'c', Values,
					equiv(
						equal([C, A - B]),
						equal([B + C, A])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{difference_definition}

Z této rovnice například vyplývá, že \(5 - 2 = 3\) protože \(2 + 3 = 5\). Vidíme ale, že pro některé dvojice přirozených čísel rozdíl neexistuje. Například nelze vypočítat \(2 - 3\), protože neexistuje přirozené číslo, které kdybychom přičetli k číslu 3, tak dostaneme číslo 2. Potřebovali bychom číslo, které je menší než nejmenší přirozené číslo 1. Abychom mohli taková čísla zavést, tak musíme opustit náš dosavadní model reprezentace čísel pomocí počtu jedniček nebo objektů a~definovat čísla jejich pořadím podle tabulky~\ref{tab:integers}. Celá čísla můžeme zobrazit na číselné ose jako na obrázku~\ref{img:integer_number_line}.

\begin{table}[ht]
\centering
\begin{tabular}{|r|r|}
\hline
Číslo & Pořadí \\
\hline
\ldots & \ldots \\
-4 & -5 + 1 \\
-3 & -4 + 1 \\
-2 & -3 + 1 \\
-1 & -2 + 1 \\
0 & -1 + 1 \\
1 & 0 + 1 \\
2 & 1 + 1 \\
3 & 2 + 1 \\
4 & 3 + 1 \\
\ldots & \ldots \\
\hline
\end{tabular}
\caption{Celá čísla}
\label{tab:integers}
\end{table}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};
\end{tikzpicture}
\caption{Číselná osa}
\label{img:integer_number_line}
\end{figure}

Operace součtu zůstává definovaná pomocí tohoto pořadí a~rovnic~\eqref{eq:natural_numbers_comutativity} a~\eqref{eq:natural_numbers_asociativity}. Součet můžeme znázornit na číselné ose, jak je zobrazeno na obrázku~\ref{img:integer_add}. Abychom mohli zobrazit i~záporné sčítance, tak namísto čtverců použijeme šipky. U~kladných sčítanců míří šipka doprava, u~záporných sčítanců doleva.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};
\draw[dotted] (0, 0) -- (0, 0.5);
\draw[->, color=cyan] (0, 0.5) -- (2, 0.5);
\draw[dotted] (2, 0.5) -- (2, 1);
\draw[->, color=orange] (2, 1) -- (-1, 1);
\end{tikzpicture}
\caption{Grafické znázornění součtu \(\textcolor{cyan}{2} + (-\textcolor{orange}{3})\)}
\label{img:integer_add}
\end{figure}

Komutativita součtu je znázorněna na obrázku~\ref{img:integer_add_comutativity} a~asociativita na obrázku~\ref{img:integer_add_asociativity}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}

\drawhintegerline{0}{2}{-4}{4};
\draw[dotted] (0, 2) -- (0, 2.5);
\draw[->, color=cyan] (0, 2.5) -- (2, 2.5);
\draw[dotted] (2, 2.5) -- (2, 3);
\draw[->, color=orange] (2, 3) -- (-1, 3);

\drawhintegerline{0}{0}{-4}{4};
\draw[dotted] (0, 0) -- (0, 0.5);
\draw[->, color=orange] (0, 0.5) -- (-3, 0.5);
\draw[dotted] (-3, 0.5) -- (-3, 1);
\draw[->, color=cyan] (-3, 1) -- (-1, 1);

\end{tikzpicture}
\caption{Grafické znázornění komutativity součtu \(\textcolor{cyan}{2} + (-\textcolor{orange}{3}) = -\textcolor{orange}{3} + \textcolor{cyan}{2}\)}
\label{img:integer_add_comutativity}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tikzpicture}

\drawhintegerline{0}{3}{-4}{4};
\draw[dotted] (0, 3) -- (0, 3.5);
\draw[->, color=cyan] (0, 3.5) -- (2, 3.5);
\draw[dotted] (2, 3.5) -- (2, 4);
\draw[->, color=orange] (2, 4) -- (-1, 4);
\draw[dotted] (-1, 4) -- (-1, 4.5);
\draw[->, color=green] (-1, 4.5) -- (3, 4.5);

\drawhintegerline{0}{0}{-4}{4};
\draw[dotted] (0, 0) -- (0, 1);
\draw[->, color=cyan] (0, 0.5) -- (2, 0.5);

\draw[->, color=orange] (0, 1) -- (-3, 1);
\draw[dotted] (-3, 1) -- (-3, 1.5);
\draw[->, color=green] (-3, 1.5) -- (1, 1.5);

\draw[->] (2, 0.5) -- (3, 0.5);
\draw[->] (0, 1) -- (1, 1);
\draw[dotted] (1, 1) -- (1, 1.5);
\draw[dotted] (2, 0.5) -- (0, 1);
\draw[dotted] (3, 0.5) -- (1, 1);
\end{tikzpicture}
\caption{Grafické znázornění asociativity součtu \((\textcolor{cyan}{2} + (-\textcolor{orange}{3})) + \textcolor{green}{4} = \textcolor{cyan}{2} + (-\textcolor{orange}{3} + \textcolor{green}{4})\)}
\label{img:integer_add_asociativity}
\end{figure}


Operace rozdílu je definovaná rovnicí~\eqref{eq:difference_definition} a~každé dvojici celých čísel přiřazuje celé číslo. Říkáme, že množina celých čísel je uzavřená pro operaci odčítání (to množina přirozených čísel nebyla).


Mezi celými čísly najdeme zvláštní číslo 0. Z~definice čísla 1 v~tabulce~\ref{tab:integers} vidíme, že \(0 + 1 = 1\), tedy když k~jedničce přičteme nulu, tak získáme zase jedničku. To platí obecně:

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'add_zero_proof_1',
		declare_variable(B, 'b', Values,
			equal([
				par(B + 1) + 0,
				B + par(0 + 1),
				B + 1
			])
		)
	).
\end{prolog}
\eeq{add_zero_proof_1}

V~prvním kroku jsme s~využitím komutativity a~asociativity sčítání výraz přeuspořádali. Ve druhém kroku jsme využili definice čásla 1. Protože každé celé číslo má svého předchůdce, tak můžeme zavést substituci \(a = b + 1\):

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'add_zero_proof_2',
		declare_variable(A, 'a', Values,
			equal([
				A + 0,
				A
			])
		)
	).
\end{prolog}
\eeq{add_zero_proof_2}

Srovnáme-li tento vztah se vztahem \eqref{eq:difference_definition}, dostaneme:

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'difference_itself',
		declare_variable(A, 'a', Values,
			equal([
				A - A,
				0
			])
		)
	).
\end{prolog}
\eeq{difference_itself}

Vidíme, že rovnicí~\eqref{eq:opposite_number_definition} můžeme ke každému číslu \(a\) zavést tzv. opačné číslo \(-a\). Toto číslo můžeme vypočítat podle vztahu~\eqref{eq:opposite_number_calculation}. Teď už také rozumíme proč se záporná čísla zapisují se znaménkem minus.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'opposite_number_definition',
		declare_variable(A, 'a', Values,
			equal([
				A + par(-A),
				0
			])
		)
	).
\end{prolog}
\eeq{opposite_number_definition}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'opposite_number_calculation',
		declare_variable(A, 'a', Values,
			equal([
				-A,
				0 - A
			])
		)
	).
\end{prolog}
\eeq{opposite_number_calculation}

Opačná čísla nám umožňují vypočítat rozdíl pomocí součtu jak je vidět v~rovnici~\eqref{eq:difference_by_add}.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'difference_by_add',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					A - B,
					A + 0 - B,
					A + par(-B)
				])
			)
		)
	).
\end{prolog}
\eeq{difference_by_add}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};
\end{tikzpicture}
\caption{Číselná osa}
\label{img:integer_number_line}
\end{figure}

Pokračujme rozšířením součinu na celá čísla. Začněme nulou. Srovnáním členů v~rovnici~\eqref{eq:multiplication_by_zero_1} lze odvodit vztah~\eqref{eq:multiplication_by_zero_2}.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_zero_1',
		declare_variable(A, 'a', Values,
			equal([
				A * 1,
				A * (1 + 0),
				A * 1 + A * 0
			])
		)
	).
\end{prolog}
\eeq{multiplication_by_zero_1}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_zero_2',
		declare_variable(A, 'a', Values,
			equal([A * 0, 0])
		)
	).
\end{prolog}
\eeq{multiplication_by_zero_2}

Pokračujme součinem, kde je jeden operand záporný. Z~rovnice~\eqref{eq:multiplication_by_negative_1} plyne vztah~\eqref{eq:multiplication_by_negative_2}. Díky komutativitě součinu můžeme v~rovnici~\eqref{eq:multiplication_by_negative_3} odvodit totéž pro první operand. 

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_1',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					0,
					A * (-B + B),
					A * (-B) + A * B
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_1}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_2',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					A * (-B), -par(A * B)
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_2}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_3',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					(-A) * B,
					B * (-A),
					-par(B * A),
					-par(A * B)
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_3}

Nakonec v~rovnici~\eqref{eq:multiplication_by_negative_4} vyšetříme případ, kdy jsou oba operandy záporné.

\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'multiplication_by_negative_4',
		declare_variable(A, 'a', Values,
			declare_variable(B, 'b', Values,
				equal([
					(-A) * (-B),
					-par(A * (-B)),
					-par(-par(A * B)),
					A * B
				])
			)
		)
	).
\end{prolog}
\eeq{multiplication_by_negative_4}

Nakonec rozšiřme definici mocniny na celá čísla. Začněme rozšířením mocněnce. Podle definice~\eqref{eq:power_definition} je zřejmé, že mezi sebou budeme násobit záporná čísla. Vztahy~\eqref{eq:natural_power_by_one} a~\eqref{eq:power_distributivity} proto zůstanou zachovány i~pro záporné mocněnce. Přejděme dále k~rozšíření mocnitele (exponentu) na celá čísla. Rovnici~\eqref{eq:power_by_zero_1} můžeme vydělit \(a^1\) a~získáme vztah~\eqref{eq:power_by_zero_2}.

\begin{prolog}
?-	make_test_nonzero_integers(Values),
	print_validated_formula(
		'power_by_zero_1',
		declare_variable(A, 'a', Values,
			equal([
				A^1,
				A^(0 + 1),
				A^0 * A^1
			])
		)
	).
\end{prolog}
\eeq{power_by_zero_1}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Values),
	print_validated_formula(
		'power_by_zero_2',
		declare_variable(A, 'a', Values,
			impl(
				not_equal(A, 0),
				equal([A^0, 1])
			)
		)
	).
\end{prolog}
\eeq{power_by_zero_2}

Zbývá vyšetřit hodnotu \(0^0\). Vztah~\eqref{eq:power_by_zero_2} naznačuje, že by mohlo platit \(0^0 = 1\), protože pro ostatní mocněnce umocnené na nulu dostáváme hodnotu 1. Naopak definice~\eqref{eq:power_definition} naznačuje, že by mohlo platit \(0^0 = 0\), protože nula na cokoli je rovna nula - násobíme mezi sebou samé nuly. Proto výraz \(0^0\) nemá definovanou hodnotu.

\section{Racionální čísla}

Definujme podíl jako opačnou operaci k~násobení pomocí rovnice~\eqref{eq:division_definition}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'division_definition',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				declare_variable(C, 'c', Numbers,
					equiv(
						equal([C, A / B]),
						equal([B * C, A])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{division_definition}

Z~této věty například vyplývá, že \(\frac{6}{3} = 2\) protože \(3 \cdot 2 = 6\). Vidíme ale, že pro některé dvojice celých čísel podíl neexistuje. Například nelze vypočítat \(\frac{3}{2}\), protože neexistuje celé číslo, které kdybychom vynásobili číslem 2, tak dostaneme číslo 3. Potřebovali bychom číslo, které je větší než 1 a~menší než 2. Toto omezení celách čísel můžeme obejít tak, že jako číslo definujeme podíl dvou celých čísel a~nazveme ho racionální číslo. Množinu všech racionálních čísel označíme \(\rationals\):

\begin{equation}
\forall a \in \integers \ \forall b \in (\integers \setminus \{0\}) \ \frac{a}{b} \in \rationals
\end{equation}

Racionální čísla jsou tedy zlomky. Číslu, které dělíme, říkáme čitatel. Číslu, kterým děláme, říkáme jmenovatel. Jmenovatel nemůže být nulový. Podle věty~\eqref{eq:division_definition} bychom pro \(b = 0\) totiž museli najít hodnotu \(c\) splňující podmínku \(0 \cdot c = a\). Mohou nastat dva případy:

\begin{itemize}
	\item \(a = 0\), pak může být \(c\) jakékoli.
	\item \(a \neq 0\), pak odpovídající hodnota \(c\) neexistuje. 
\end{itemize}

V~obou případech nemá zlomek definovanou hodnotu. Proto nulou dělit nelze.

Graficky lze kladná racionální čísla zobrazit jako boxy. Čitatel určuje počet boxů, jmenovatel kolik boxů se vejde do jednotky. Racionální čísla tedy mohou být mezi celými čísly jak vidíme na obrázku~\ref{img:rational_definition}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-1}{2}
\drawboxrowrational{0}{0}{3}{2}{1}{fill=lightgray}
\end{tikzpicture}
\caption{Grafické znázornění racionálního čísla \(\frac{3}{2}\)}
\label{img:rational_definition}
\end{figure}

Vyjádřeme násobení racionálních čísel v~soustavě~\eqref{eq:rational_multiplication}. Mějme dvě racionální čísla \(c\) a~\(f\) zapsaná jako zlomky. Potom můžeme podle věty~\eqref{eq:division_definition} zapsat jejich definici součinem. Z~nich můžeme vyjádřit součin \(a \cdot d\), ze kterého podle věty~\eqref{eq:division_definition} vyjádříme součin racionálních čísel.

\begin{prolog}
?-	Numbers = [1, 2, 3, 4, 6],
	print_validated_formula(
		'rational_multiplication',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					declare_variable(D, 'd', Numbers,
						declare_variable(E, 'e', Numbers,
							declare_variable(F, 'f', Numbers,
								proof([
									equal([C, A / B]),
									equal([F, D / E])
								],
								[
									equal([A, B * C]),
									equal([D, E * F]),
									equal([A * D, par(B * C) * par(E * F), par(B * E) * par(C * F)]),
									equal([(C * F), (A / B) * (D / E), (A * D) / (B * E)])
								])
							)
						)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{rational_multiplication}

Graficky můžeme znázornit násobení racionálních čísel jako na obrázku~\ref{img:rational_multiplication_definition}.
Je zde obdélník, jehož strany mají délku danou násobenými čísly. Tyto strany mají počet boxů daný čitateli násobených čísel a~velikost boxů je taková, aby se do jednotky vešel počet boxů odpovídající jmenovateli násobených čísel. Součin je zlomek. Čitatel součinu odpovídá celkovému počtu boxů, tedy součinu čitatelů násobených čísel. Jmenovatel součinu odpovídá počtu boxů, které se vejdou do jednotkového čtverce, tedy součinu jmenovatelů násobených čísel. V~uvedeném příkladě tedy máme 15 boxů, přičemž 6 boxů tvoří jednotkový čtverec (na obrázku šedě podbarveno). Je zřejmé, že i~součin racionálních čísel je komutativní a~asociativní, protože jsou komutativní a~asociativní součiny čísel v~čitatelích a jmenovatelích. Graficky je komutativita znázorněna na obrázku~\ref{img:rational_multiplication_comutativity}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawrect{0}{0}{1}{1}{fill=lightgray};
\drawnaturalnumberplane{0}{0}{2}{2};
\drawboxrectrational{0}{0}{3}{2}{5}{3}{fill=orange};
\end{tikzpicture}
\caption{Grafické znázornění součinu \(\frac{3}{2} \cdot \frac{5}{3} = \frac{15}{6}\)}
\label{img:rational_multiplication_definition}
\end{figure}


\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawrect{0}{0}{1}{1}{fill=lightgray};
\drawnaturalnumberplane{0}{0}{2}{2};
\drawboxrectrational{0}{0}{3}{2}{5}{3}{fill=orange};

\drawrect{3}{0}{4}{1}{fill=lightgray};
\drawnaturalnumberplane{3}{0}{2}{2};
\drawboxrectrational{3}{0}{5}{3}{3}{2}{fill=cyan};
\end{tikzpicture}
\caption{Grafické znázornění komutativity součinu \(\textcolor{orange}{\frac{3}{2} \cdot \frac{5}{3}} = \textcolor{cyan}{\frac{5}{3} \cdot \frac{3}{2}}\)}
\label{img:rational_multiplication_comutativity}
\end{figure}

Z~definice~\eqref{eq:division_definition} dále plyne vztah~\eqref{eq:rational_one} definující podíl stejných čísel.

\begin{prolog}
?-	make_test_nonzero_numbers(Numbers),
	print_validated_formula(
		'rational_one',
		declare_variable(A, 'a', Numbers,
			equal([A / A, 1])
		)
	).
\end{prolog}
\eeq{rational_one}

Ze vztahů~\eqref{eq:rational_multiplication} a~\eqref{eq:rational_one} můžeme odvodit vztah~\eqref{eq:rational_reduction} umožňující rozšíření nebo naopak krácení zlomků. Tento vztah nám umožňuje zapsat racionální čísla ve tvaru, kdy jmenovatel je přirozené číslo (tedy kladný) a~čitatel a~jmenovatel jsou nesoudělní.

\begin{prolog}
?-	make_test_nonzero_numbers(Numbers),
	print_validated_formula(
		'rational_reduction',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					equal([
						A / B,
						(A / B) * 1,
						(A / B) * (C / C),
						(A * C) / (B * C)
					])
				)
			)
		)
	).
\end{prolog}
\eeq{rational_reduction}

Dále můžeme odvodit vztah~\eqref{eq:division_distributivity} pro distributivitu podílu. Tento vztah nám umožňuje vypočítat součet a~rozdíl zlomků se stejným jmenovatelem.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'division_distributivity',
		declare_plus_minus(PM,
			declare_variable(A, 'a', Numbers,
				declare_variable(B, 'b', Numbers,
					declare_variable(C, 'c', NonzeroNumbers,
						equal([
							plus_minus(A, B, PM) / C,
							plus_minus(A, B, PM) * (1 / C),
							plus_minus(A * (1 / C), B * (1 / C), PM),
							plus_minus(A / C, B / C, PM)
						])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{division_distributivity}

Pokud chceme vypočítat součet nebo rozdíl zlomků s~rozdílnými jmenovateli, pak je musíme převést na společného jmenovatele, jak je vidět ve vztahu~\eqref{eq:sum_of_rationals}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'sum_of_rationals',
		declare_plus_minus(PM,
			declare_variable(A, 'a', Numbers,
				declare_variable(B, 'b', NonzeroNumbers,
					declare_variable(C, 'c', Numbers,
						declare_variable(D, 'd', NonzeroNumbers,
							equal([
								plus_minus(A / B, C / D, PM),
								plus_minus((A * D) / (B * D), (C * B) / (D * B), PM),
								plus_minus(A * D, B * C, PM) / (B * D)
							])
						)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{sum_of_rationals}

Graficky je součet racionálních čísel zobrazen na obrázku~\ref{img:add_rational_numbers}. Sčítáme třetiny a~poloviny, ty mají ale jinak veliké boxy. Proto každý třetinový box rozdělíme na dva stejné a~každý polovinový box rozdělíme na tři stejné. Získáme tak boxy o~velikosti jedné šestiny jednotky, ty pak už můžeme sčítat.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawboxrowrational{0}{1}{4}{3}{1}{fill=cyan}
\drawboxrowrational{4 / 3}{1}{3}{2}{1}{fill=orange}

\drawhintegerline{0}{0}{0}{3}
\drawboxrowrational{0}{0}{8}{6}{1}{fill=cyan}
\drawboxrowrational{4 / 3}{0}{9}{6}{1}{fill=orange}
\end{tikzpicture}
\caption{Grafické znázornění součtu \(\textcolor{cyan}{\frac{4}{3}} + \textcolor{orange}{\frac{3}{2}} = \textcolor{cyan}{\frac{8}{6}} + \textcolor{orange}{\frac{9}{6}} = \frac{17}{6}\)}
\label{img:add_rational_numbers}
\end{figure}

Nakonec můžeme rovnicí~\eqref{eq:division_of_rationals} vyjádřit podíl racionálních čísel.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'division_of_rationals',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				declare_variable(C, 'c', NonzeroNumbers,
					declare_variable(D, 'd', NonzeroNumbers,
						equal([
							(A / B) / (C / D),
							((A / B) / (C / D)) * ((D / C) / (D / C)),
							((A * D) / (B * C)) / ((C * D) / (D * C)),
							((A * D) / (B * C)) / 1,
							(A * D) / (B * C)
						])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{division_of_rationals}

Nakonec rozšiřme definici mocniny na racionální čísla. Podle definice~\eqref{eq:power_definition} můžeme rozšířit mocněnce na racionální čísla tak, že mezi sebou budeme násobit racionální čísla. Vztahy~\eqref{eq:natural_power_by_one} a~\eqref{eq:power_distributivity} proto zůstanou zachovány i~pro racionální mocněnce. 
Dále můžeme s~racionálními čísly vyjádřit mocniny se zápornými exponenty. Z~rovnice~\eqref{eq:power_by_negative_exponent_1} plyne rovnice~\eqref{eq:power_by_negative_exponent_2}. Speciálním případem je rovnice~\eqref{eq:power_by_negative_exponent_3} udávající, že umocnění čísla na \(-1\) je rovno jeho převrácené hodnotě.

\begin{prolog}
?-	make_test_nonzero_integers(TestBases),
	make_test_integers(TestExponents),
	print_validated_formula(
		'power_by_negative_exponent_1',
		declare_variable(A, 'a', TestBases,
			declare_variable(B, 'b', TestExponents,
				impl(
					not_equal(A, 0),
					equal([
						1,
						A^0,
						A^(-B + B),
						A^(-B) * A^B
					])
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_negative_exponent_1}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_nonzero_integers(TestBases),
	make_test_integers(TestExponents),
	print_validated_formula(
		'power_by_negative_exponent_2',
		declare_variable(A, 'a', TestBases,
			declare_variable(B, 'b', TestExponents,
				impl(
					not_equal(A, 0),
					equal([A^(-B), 1 / (A^B)])
				)
			)
		)
	).
\end{prolog}
\eeq{power_by_negative_exponent_2}
%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_nonzero_integers(TestBases),
	print_validated_formula(
		'power_by_negative_exponent_3',
		declare_variable(A, 'a', TestBases,
			impl(
				not_equal(A, 0),
				equal([A^(-1), 1 / A])
			)
		)
	).
\end{prolog}
\eeq{power_by_negative_exponent_3}

\section{Uspořádání čísel}

Operátor rovnosti už známe ze sekce~\ref{sec:equality_operator}. Nyní definujeme, která čísla jsou menší a~která jsou větší. Idea je taková, že máme-li dvě celá (a~tedy i~přirozená) čísla, tak se z~menšího čísla můžeme udělat větší postupným přičítáním jedniček. Větší číslo je tedy v~tabulce~\ref{tab:integers} níže a~menší číslo výše. Uděláme-li rozdíl mezi větším a~menším číslem, tak tedy vyjde kladný. Proto definujeme:

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_equal',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					equal(A, B),
					equal(A - B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_equal}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_than(A, B),
					less_than(A - B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_than}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_greater_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					greater_than(A, B),
					greater_than(A - B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_greater_than}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_or_equal',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_or_equal(A, B),
					or(
						less_than(A, B),
						equal(A, B)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_or_equal}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_greater_or_equal',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					greater_or_equal(A, B),
					or(
						greater_than(A, B),
						equal(A, B)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_greater_or_equal}
\end{fact}

Stačí tedy definovat, která čísla jsou kladná a~která záporná. Začněme celými čísly. Zde je situace jednoduchá - přirozená čísla jsou kladná a~k~nim opačná čísla jsou záporná:

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_positive_integers',
		forall_in(N, 'n', natural_numbers, Numbers,
			greater_than(N, 0)
		)
	).
\end{prolog}
\eeq{order_positive_integers}
%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_positive_negative',
		forall_in(N, 'n', natural_numbers, Numbers,
			less_than(-N, 0)
		)
	).
\end{prolog}
\eeq{order_positive_negative}
\end{fact}

Přejděme k~racionálním číslům. Podle rovnice~\eqref{eq:order_rationals_1} můžeme každé racionální číslo rozšířit tak, že jeho jmenovatel bude kladný. Potom je znaménko určeno čitatelem takto rozšířeného zlomku. Platí proto vztahy~\eqref{eq:order_rationals_positive} a~\eqref{eq:order_rationals_negative}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'order_rationals_1',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				equal(A / B, (A * B) / (B * B))
			)
		)
	).
\end{prolog}
\eeq{order_rationals_1}

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'order_rationals_positive',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				equiv(
					greater_than(A / B, 0),
					greater_than(A * B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_rationals_positive}
%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'order_rationals_negative',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', NonzeroNumbers,
				equiv(
					less_than(A / B, 0),
					less_than(A * B, 0)
				)
			)
		)
	).
\end{prolog}
\eeq{order_rationals_negative}
\end{fact}

Graficky můžeme zobrazit uspořádání čísel na číselné ose jako na obrázku~\ref{img:ordering}. Tučnou čarou je zobrazeno číslo 1. Vlevo od něj azurovou barvou je zobrazena množina čísel menších než 1. Vpravo oranžovou barvou množina čísel větších než 1.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawhintegerline{0}{0}{-4}{4};

\drawrect{-4.2}{0}{1}{1}{fill=cyan};
\draw (-1.5, 0.5) node{\(\{x: x < 1\}\)};

\drawrect{1}{0}{4.2}{1}{fill=orange};
\draw (2.5, 0.5) node{\(\{x: x > 1\}\)};

\draw[thick] (1, -0.2) -- (1, 1.2);

\end{tikzpicture}
\caption{Grafické znázornění uspořádání čísel}
\label{img:ordering}
\end{figure}

Z~definic~\eqref{eq:order_less_than} a~\eqref{eq:order_at_least_one} také plynou věty~\eqref{eq:order_not_less_than} až~\eqref{eq:order_less_or_equal_opposite}. Tyto věty vyjadřují fakt, že vždy platí právě jedna z~relací \(a < b\), \(a = b\), \(a > b\).

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_at_least_one',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				or(
					or(
						less_than(A, B),
						equal(A, B)
					),
					greater_than(A, B)
				)
			)
		)
	).
\end{prolog}
\eeq{order_at_least_one}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_not_less_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					not(less_than(A, B)),
					greater_or_equal(A, B)
				)
			)
		)
	).
\end{prolog}
\eeq{order_not_less_than}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_not_greater_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					not(greater_than(A, B)),
					less_or_equal(A, B)
				)
			)
		)
	).
\end{prolog}
\eeq{order_not_greater_than}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_than_opposite',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_than(A, B),
					greater_than(B, A)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_than_opposite}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_less_or_equal_opposite',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				equiv(
					less_or_equal(A, B),
					greater_or_equal(B, A)
				)
			)
		)
	).
\end{prolog}
\eeq{order_less_or_equal_opposite}
\end{fact}

Předpokládejme, že platí \(a > b\) a \(b > c\). Tyto relace nejdříve rozepíšeme podle definice~\eqref{eq:order_less_than}. Následně využijeme faktu, že součet klasných čísel je kladné číslo (viz~\eqref{eq:order_positive_integers} a~\eqref{eq:order_rationals_positive}). Úpravou pak získáme \(a > c\). Výsledek je zapsán ve větě~\eqref{eq:order_transitivity_greater_than} a~říká se mu tranzitivita. Obdobně platí věta~\eqref{eq:order_transitivity_less_than}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_transitivity_proof',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					proof([
						greater_than(A, B),
						greater_than(B, C)
					],
					[
						greater_than(A - B, 0),
						greater_than(B - C, 0),
						greater_than(par(A - B) + par(B - C), 0),
						greater_than(A - C, 0),
						greater_than(A, C)
					])
				)
			)
		)
	).
\end{prolog}
\eeq{order_transitivity_proof}

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_transitivity_greater_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					impl(
						and(
							greater_than(A, B),
							greater_than(B, C)
						),
						greater_than(A, C)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_transitivity_greater_than}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'order_transitivity_less_than',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					impl(
						and(
							less_than(A, B),
							less_than(B, C)
						),
						less_than(A, C)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{order_transitivity_less_than}
\end{fact}

Graficky je tranzitivita zobrazena na obrázku~\ref{img:ordering_transitivity}. Díky tranzitivitě platí, že jakékoli číslo z~množiny \(A\) je menší než jakékoli číslo z~množiny \(C\).

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\drawrect{-4.2}{0}{0}{1}{fill=cyan};
\draw (-2, 0.5) node{\(A = \{a: a < b\}\)};

\drawrect{0}{0}{4.2}{1}{fill=orange};
\draw (2, 0.5) node{\(C = \{c: c > b\}\)};

\draw[thick] (0, -0.2) -- (0, 1.2);
\draw (0, -0.2) node[anchor=north]{\(b\)};

\draw[<->] (-4.5, 0) -- (4.5, 0);
\end{tikzpicture}
\caption{Grafické znázornění tranzitivity uspořádání čísel}
\label{img:ordering_transitivity}
\end{figure}

