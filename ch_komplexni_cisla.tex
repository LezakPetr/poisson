\chapter{Komplexní čísla}


\begin{prolog}
:- ensure_loaded("../equations/formula").
:- ensure_loaded("../equations/truth_table").
:- ensure_loaded("../equations/draw_1d_function").

make_test_numbers([-1, 0, 0.5, 1, 2, 3, 1.5, complex(0, 1), complex(0, -1), complex(1, 1)]).
make_test_real_numbers([-2, -1, 0, 1, 1.5, 2]).
make_test_real_nonzero_numbers([-2, -1, 1, 1.5, 2]).
make_test_complex_functions(Z, [Z + 2, Z - imag, (1 - imag) * Z, Z^2]).
make_test_real_binary_functions(X, Y, [X + Y, X * Y, X^2 * Y, Y^2 * X]).

make_test_harmonic_functions(
	UX, UY, VX, VY,
	[
		[UX^2 - UY^2, 2 * VX * VY],
		[UX^3 - 3 * UX * UY^2, 3 * VX^2 * VY - VY^3]
	]
).
\end{prolog}

\section{Zavedení komplexních čísel}

V~sekci \ref{sec:realna_cisla} věnované reálným číslům jsme větou~\eqref{eq:sqrt_def} definovali odmocninu kladných čísel. Důvodem tohoto omezení je fakt, že v oboru reálných čísel neexistují sudé odmocniny ze záporných čísel. Například rovnice \(x^2 = -1\) nemá v~oboru reálných čísel řešení, neexistuje proto \(\sqrt{-1}\). Abychom mohli takovéto rovnice řešit, tak rovnicí~\eqref{eq:imag_def} zavedeme imaginární jednotku \(\imag\).

\begin{fact}
\begin{prolog}
?-	print_validated_formula(
		'imag_def',
		equal(imag^2, -1)
	).
\end{prolog}
\eeq{imag_def}
\end{fact}

Uvažujme dvě reálná čísla \(a\) a~\(b\), z~nichž alespoň jedno je nenulové. Chtějme nalézt takovou kombinaci těchto čísel, aby platilo:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_units_ortogonality',
		declare([variable(A, 'a', Numbers), variable(B, 'b', Numbers)],
			proof([
				equal(A * 1 + B * imag, 0)
			],
			[
				equal(A * 1, -B * imag),
				equal(A^2 * 1^2, B^2 * imag^2),
				equal(A^2, -B^2),
				equal(A^2 + B^2, 0)
			])
		)
	).
\end{prolog}
\eeq{complex_units_ortogonality}

Vidíme, že pro nenulová čísla tato rovnice nemůže být splněna. Reálná jednotka \(1\) a~imaginární jednotka \(\imag\) jsou proto navzájem ortogonální - jednu není možné vyjádřit pomocí druhé. Tyto jednotky si tedy můžeme představit jako vzájemně kolmé jednotkové osy ve dvojrozměrném prostoru. Každý bod v~tomto prostoru můžeme popsat jako lineární kombinaci těchto jednotek. Proto tuto lineární kombinaci \(a + b \cdot \imag\) nazveme komplexním číslem zapsaným v~algebraickém tvaru. Množinu všech komplexních čísel označíme \(\complex\).

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_def',
		forall_in([A, B], ['a', 'b'], real_numbers, Numbers,
			in(A + B * imag, complex_numbers)
		)
	).
\end{prolog}
\eeq{complex_def}
\end{fact}

Vyjádřeme operace s~komplexními čísly. Využijeme přitom faktu, že se složkami můžeme provádět algebraické operace. Začněme součtem a~rozdílem komplexních čísel. Ten provádíme po složkách:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_add',
		declare([
			plus_minus(PM), variable(A, 'a', Numbers), variable(B, 'b', Numbers),
			variable(C, 'c', Numbers), variable(D, 'd', Numbers)
		],
			equal(
				plus_minus(par(A + B * imag), par(C + D * imag), PM),
				par(plus_minus(A, C, PM)) + par(plus_minus(B, D, PM)) * imag
			)
		)
	).
\end{prolog}
\eeq{complex_add}

Součin dvou komplexních čísel můžeme vyjádřit pomocí roznásobení výrazu:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_times',
		declare([variable(A, 'a', Numbers), variable(B, 'b', Numbers), variable(C, 'c', Numbers), variable(D, 'd', Numbers)],
			equal([
				(A + B * imag) * (C + D * imag),
				A * C + A * D * imag + B * C * imag + B * D * imag^2,
				linebreak,
				par(A * C - B * D) + (A * D  + B * C) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_times}

Ke každému komplexnímu číslu \(a + b \cdot \imag\) můžeme zavést komplexně sdružené číslo \(a - b \cdot \imag\). Povšimněme si, že jejich součin daný vztahem~\eqref{eq:complex_multiply_by_conjugate} je reálný.

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		'complex_multiply_by_conjugate',
		declare([variable(A, 'a', Numbers), variable(B, 'b', Numbers)],
			equal(
				(A + B * imag) * (A - B * imag),
				A^2 + B^2
			)
		)
	).
\end{prolog}
\eeq{complex_multiply_by_conjugate}

Toho můžeme využít pro vyjádření podílu dvou komplexních čísel:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_real_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'complex_fraction',
		declare([
			variable(A, 'a', Numbers), variable(B, 'b', Numbers),
			variable(C, 'c', NonzeroNumbers), variable(D, 'd', NonzeroNumbers)
		],
			equal([
				(A + B * imag) / (C + D * imag),
				((A + B * imag) * (C - D * imag)) / ((C + D * imag) * (C - D * imag)),
				linebreak,
				(A * C + B * D + B * C * imag - A * D * imag) / (C^2 + D^2),
				(A * C + B * D) / (C^2 + D^2) + (B * C - A * D) / (C^2 + D^2) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_fraction}

Absolutní hodnota komplexního čísla \(x + Y \cdot \imag\) je dána výrazem \eqref{eq:complex_abs}. Jeho srovnáním se vztahem \eqref{eq:euklidovsky_prostor_metrika} dospějeme k~závěru, že komplexní rovina odpovídá dvojrozměrnému Euklidovskému prostoru.

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		'complex_abs',
		declare([variable(X, 'x', Numbers), variable(Y, 'y', Numbers)],
			equal(abs(X + Y * imag), sqrt(X^2 + Y^2))
		)
	).
\end{prolog}
\eeq{complex_abs}

\section{Komplexní funkce, limita, derivace}

Mějme komplexní funkci komplexní proměnné \(z\):

\begin{equation}
w = \func{f}(z); z, w \in \complex
\end{equation}

Tuto funkci můžeme rozepsat na dvě reálné funkce dvou reálných proměnných:

\begin{equation}
\func{f}(x + y \cdot \imag) = \func{u}(x, y) + \func{v}(x, y) \cdot \imag
\end{equation}

Limitu komplexní funkce definujeme jako limitu funkce dvou parametrů. Znamená to tedy, že funkční hodnota se limitě musí blížit \uv{ze všech směrů}.

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_complex_functions(P, Functions),
	print_validated_formula(
		'complex_lim',
		declare([variable(X0, 'x_0', Numbers), variable(Y0, 'y_0', Numbers), function(F, '\\func{f}', Functions)],
			equal(
				lim(Z, 'z', complex, X0 + Y0 * imag, apply(F, [P], [Z])),
				lim([X, Y], ['x', 'y'], [real, real], [X0, Y0], apply(F, [P], [X + Y * imag]))
			)
		)
	).
\end{prolog}
\eeq{complex_lim}

Derivaci komplexní funkce definujeme obdobně jako derivaci reálné funkce pomocí vztahu~\eqref{eq:complex_derivative}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_complex_functions(P, Functions),
	print_validated_formula(
		"complex_derivative",
		declare([function(F, "\\func{f}", Functions), variable(Z, 'z', Numbers)],
			equal(
				derivative(Z, apply(F, [P], [Z])),
				lim(DZ, "\\mathrm{d}z", complex, 0, (apply(F, [P], [Z + DZ]) - apply(F, [P], [Z])) / DZ)
			)
		)
	).
\end{prolog}
\eeq{complex_derivative}

Zabývejme se otázkou, kdy tato derivace existuje. Nejdříve rozepišme definici derivace~\eqref{eq:complex_derivative} na podíl diferenciálů. Zavedeme tedy označení \(\func{f}(z + \mathrm{d}z) - \func{f}(z) = \mathrm{d}u + \mathrm{d}v \cdot \imag\) a~\(\mathrm{d}z = \mathrm{d}x + \mathrm{d}y \cdot \imag\):

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_1",
		declare([
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU + DV * imag) / (DX + DY * imag)
				),
				lim([DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					((DU + DV * imag) / (DX + DY * imag)) * ((DX - DY * imag) / (DX - DY * imag))	
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU * DX + DV * DY + (DV * DX - DU * DY) * imag) / (DX^2 + DY^2)
				)
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_1}

Uvědomme si, že limita~\eqref{eq:complex_derivative_conditions_1} je definována pro dvojici proměnných~\(\mathrm{d}x\) a~\(\mathrm{d}y\). Proto můžeme zvolit \(\mathrm{d}x = 0\) a~limita se tím nezmění:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_2",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU + DV * imag) / (DX + DY * imag)
				),
				declare([substitution(DX, "\\mathrm{d}x", 0)],
					lim(
						DY, "\\mathrm{d}y", real, 0,
						(DV * DY - DU * DY * imag) / DY^2
					)
				),
				linebreak,
				declare([substitution(DX, "\\mathrm{d}x", 0)],
					lim(
						DY, "\\mathrm{d}y", real, 0,
						(DV - DU * imag) / DY
					)
				),
				derivative(Y, apply(V, [VX, VY], [X, Y])) - derivative(Y, apply(U, [UX, UY], [X, Y])) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_2}

Obdobně můžeme zvolit \(\mathrm{d}y = 0\) a~získáme:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_3",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU + DV * imag) / (DX + DY * imag)
				),
				declare([substitution(DY, "\\mathrm{d}y", 0)],
					lim(
						DX, "\\mathrm{d}x", real, 0,
						(DU * DX + DV * DX * imag) / DX^2
					)
				),
				linebreak,
				declare([substitution(DY, "\\mathrm{d}y", 0)],
					lim(
						DX, "\\mathrm{d}x", real, 0,
						(DU + DV * imag) / DX
					)
				),
				derivative(X, apply(U, [UX, UY], [X, Y])) + derivative(X, apply(V, [VX, VY], [X, Y])) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_3}

Srovnejme vztahy~\eqref{eq:complex_derivative_conditions_2} a~\eqref{eq:complex_derivative_conditions_3}. Dvě komplexní čísla jsou shodná, pokud mají stejnou reálnou i~imaginární složku. Proto má-li komplexní funkce derivaci, tak bude platit:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_4",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions),
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers)
		],
			and(
				equal(derivative(X, apply(U, [UX, UY], [X, Y])), derivative(Y, apply(V, [VX, VY], [X, Y]))),
				equal(derivative(Y, apply(U, [UX, UY], [X, Y])), -derivative(X, apply(V, [VX, VY], [X, Y])))
			)
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_4}

Podmínky~\eqref{eq:complex_derivative_conditions_4} se nazývají Cauchyovy-Riemannovy podmínky. 
Má-li komplexní funkce derivaci v~každém bodě určité oblasti, pak říkáme, že je v~této oblasti analytická.

Zabývejme se otázkou, zda je splnění podmínek~\eqref{eq:complex_derivative_conditions_4} postačující k~existenci derivace komplexní funkce. Ve vztazích~\eqref{eq:complex_derivative_conditions_2} a~\eqref{eq:complex_derivative_conditions_3} jsme položili \(\mathrm{d}x = 0\) respektive \(\mathrm{d}y = 0\), uvažovali jsme tedy pouze okolní body se stejnou reálnou respektive imaginární složkou. Potřebujeme ale ověřit, že všechny okolní body se blíží k~limitě~\eqref{eq:complex_derivative_conditions_1}. Pokračujme proto upravováním vztahu
~\eqref{eq:complex_derivative_conditions_1}

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_5",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU * DX + DV * DY + (DV * DX - DU * DY) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					((DU / DX) * DX^2 + (DV / DY) * DY^2 + ((DV / DX) * DX^2 - (DU / DY) * DY^2) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(derivative(X, apply(U, [UX, UY], [X, Y])) * DX^2 + derivative(Y, apply(V, [VX, VY], [X, Y])) * DY^2 + (derivative(X, apply(V, [VX, VY], [X, Y])) * DX^2 - derivative(Y, apply(U, [UX, UY], [X, Y])) * DY^2) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(derivative(X, apply(U, [UX, UY], [X, Y])) * DX^2 + derivative(X, apply(U, [UX, UY], [X, Y])) * DY^2 + (derivative(X, apply(V, [VX, VY], [X, Y])) * DX^2 + derivative(X, apply(V, [VX, VY], [X, Y])) * DY^2) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(derivative(X, apply(U, [UX, UY], [X, Y])) * (DX^2 + DY^2) + (derivative(X, apply(V, [VX, VY], [X, Y])) * (DX^2 + DY^2)) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					derivative(X, apply(U, [UX, UY], [X, Y])) + derivative(X, apply(V, [VX, VY], [X, Y])) * imag
				)
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_5}

Vidíme, že podmínky~\eqref{eq:complex_derivative_conditions_4} jsou podmínky nutné i~postačující.

\section{Funkce sinus a~kosinus}

Úhel sevřený dvěma polopřímkami se společným bodem v~obloukové míře je udáván délkou oblouku, které tyto dvě polopřímky vytknou na jednotkové kruřnici. Udává se v~radiánech. Plný úhel má proto velikost \(2 \pi \ \rad\), přímý úhel \(\pi \ \rad\) a~pravý úhel \(\frac{\pi}{2} \ \rad\).

\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}

\pgfmathsetmacro{\ang}{45}
\pgfmathsetmacro{\r}{4}
\pgfmathsetmacro{\p}{5}
\pgfmathsetmacro{\x}{cos(\ang)}
\pgfmathsetmacro{\y}{sin(\ang)}

\draw (0, 0) -- (\r, 0);
\draw[dashed] (\r, 0) -- (\p, 0);
\draw (\r / 2, 0) node[anchor=north]{1};

\draw (0, 0) -- (\r * \x, \r * \y);
\draw[dashed] (\r * \x, \r * \y) -- (\p * \x, \p * \y);
\draw (\r / 2 * \x, \r / 2 * \y) node[anchor=south east]{1};

\draw[->] (\r, 0) arc(0:\ang:\r);
\draw (\r * 0.92388, \r * 0.38268) node[anchor=west]{\(\alpha\)};
\end{tikzpicture}
\caption{Oblouková míra úhlu}
\end{center}
\label{img:rad_def}
\end{figure}

Mějme nyní pravoúhlý trojúhelník s~přeponou délky 1.

\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}

\pgfmathsetmacro{\r}{4}

\pgfmathsetmacro{\ang}{30}
\pgfmathsetmacro{\x}{cos(\ang)}
\pgfmathsetmacro{\y}{sin(\ang)}

\draw (0, 0) -- (\r * \x, 0) -- (\r * \x, \r * \y) -- (0, 0);

\draw (\r * \x / 2, 0) node[anchor=north]{\(\cos \alpha\)};
\draw (\r * \x, \r * \y / 2) node[anchor=west]{\(\sin \alpha\)};
\draw (\r / 2 * \x, \r / 2 * \y) node[anchor=south]{1};

\draw[<->] (1, 0) arc(0:\ang:1);
\draw (0.96593, 0.2) node[anchor=east]{\(\alpha\)};
\drawrightangle{\r * \x}{0}{0.3}{90};
\end{tikzpicture}
\caption{Definice sinu a~kosinu}
\end{center}
\label{img:sin_cos_def}
\end{figure}



\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}

\pgfmathsetmacro{\r}{10}

\pgfmathsetmacro{\ang}{30}
\pgfmathsetmacro{\x}{cos(\ang)}
\pgfmathsetmacro{\y}{sin(\ang)}

\pgfmathsetmacro{\angb}{40}
\pgfmathsetmacro{\xb}{cos(\angb)}
\pgfmathsetmacro{\yb}{sin(\angb)}

\draw (0, 0) -- (\r * \x, 0) -- (\r * \x, \r * \y) -- (0, 0);

\draw[dashed] (\r * \x, 0) -- (\r, 0);
\draw (\r * \x / 2, 0) node[anchor=north]{\(\cos \alpha\)};
\draw (\r * \x, \r * \y / 2) node[anchor=west]{\(\sin \alpha\)};
\draw (\r / 2 * \x, \r / 2 * \y) node[anchor=north]{1};

\draw (0, 0) -- (\r * \xb, \r * \yb) -- (\r * \x, \r * \y) -- (\r * \xb, \r * \y) -- (\r * \xb, \r * \yb);
\draw[dashed] (\r * \xb, \r * \y) -- (\r * \xb, 0);

\draw(\r, 0) arc(0:50:\r);

\draw[<->] (1, 0) arc(0:\ang:1);
\draw (0.96593, 0.2) node[anchor=east]{\(\alpha\)};

\drawsmallangle{0}{0}{1.5}{\ang}{\angb}{\(\mathrm{d}\alpha\)};
\drawrightangle{\r * \xb}{\r * \y}{0.3}{0};

\draw (\r * \x / 2 + \r * \xb / 2, \r * \y / 2 + \r * \yb / 2) node[anchor=west]{\(\mathrm{d}\alpha\)};
\draw (\r * \xb, \r * \y / 2 + \r * \yb / 2) node[anchor=east]{\(\cos \mathrm{d}\alpha\)};
\draw (\r * \x / 2 + \r * \xb / 2, \r * \y) node[anchor=north]{\(\sin \mathrm{d}\alpha\)};

\drawsmallangle{\r * \xb}{\r * \yb}{0.5}{270}{270 + \angb}{\(\alpha\)};
\drawrightangle{\r * \x}{0}{0.3}{90};
\end{tikzpicture}
\caption{Oblouková míra úhlu}
\end{center}
\label{img:sin_cos_derivative}
\end{figure}
