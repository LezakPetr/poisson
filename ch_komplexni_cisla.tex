\chapter{Komplexní čísla}


\begin{prolog}
:- ensure_loaded("../equations/formula").
:- ensure_loaded("../equations/truth_table").
:- ensure_loaded("../equations/draw_1d_function").

make_test_numbers([-1, 0, 0.5, 1, 2, 3, 1.5, complex(0, 1), complex(0, -1), complex(1, 1)]).
make_test_real_pairs([[0, 1], [0, -1], [1, 1], [0, 0], [3, 5], [-7, 4]]).
make_test_nonzero_real_pairs([[0, 1], [0, -1], [1, 1], [3, 5], [-7, 4]]).
\end{prolog}

V~sekci \ref{sec:realna_cisla} věnované reálným číslům jsme větou~\eqref{eq:sqrt_def} definovali odmocninu kladných čísel. Důvodem tohoto omezení je fakt, že v oboru reálných čísel neexistují sudé odmocniny ze záporných čísel. Například rovnice \(x^2 = -1\) nemá v~oboru reálných čísel řešení, neexistuje proto \(\sqrt{-1}\). Abychom mohli takovéto rovnice řešit, tak rovnicí~\eqref{eq:imag_def} zavedeme imaginární jednotku \(\imag\).

\begin{fact}
\begin{prolog}
?-	print_validated_formula(
		'imag_def',
		equal(imag^2, -1)
	).
\end{prolog}
\eeq{imag_def}
\end{fact}

Uvažujme dvě reálná čísla \(a\) a~\(b\), z~nichž alespoň jedno je nenulové. Chtějme nalézt takovou kombinaci těchto čísel, aby platilo:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_units_ortogonality',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				proof([
					equal(A * 1 + B * imag, 0)
				],
				[
					equal(A * 1, -B * imag),
					equal(A^2 * 1^2, B^2 * imag^2),
					equal(A^2, -B^2),
					equal(A^2 + B^2, 0)
				])
			)
		)
	).
\end{prolog}
\eeq{complex_units_ortogonality}

Vidíme, že pro nenulová čísla tato rovnice nemůže být splněna. Reálná jednotka \(1\) a~imaginární jednotka \(\imag\) jsou proto navzájem ortogonální - jednu není možné vyjádřit pomocí druhé. Tyto jednotky si tedy můžeme představit jako vzájemně kolmé jednotkové osy ve dvojrozměrném prostoru. Každý bod v~tomto prostoru můžeme popsat jako lineární kombinaci těchto jednotek. Proto tuto lineární kombinaci \(a + b \cdot \imag\) nazveme komplexním číslem zapsaným v~algebraickém tvaru. Množinu všech komplexních čísel označíme \(\complex\).

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_def',
		forall_in([A, B], ['a', 'b'], real_numbers, Numbers,
			in(A + B * imag, complex_numbers)
		)
	).
\end{prolog}
\eeq{complex_def}
\end{fact}

Vyjádřeme operace s~komplexními čísly. Využijeme přitom faktu, že se složkami můžeme provádět algebraické operace. Začněme součtem a~rozdílem komplexních čísel. Ten provádíme po složkách:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_add',
		declare_plus_minus(PM,
			declare_variable(A, 'a', Numbers,
				declare_variable(B, 'b', Numbers,
					declare_variable(C, 'c', Numbers,
						declare_variable(D, 'd', Numbers,
							equal(
								plus_minus(par(A + B * imag), par(C + D * imag), PM),
								par(plus_minus(A, C, PM)) + par(plus_minus(B, D, PM)) * imag
							)
						)
					)
				)
			)
		)
	).
\end{prolog}
\eeq{complex_add}

Součin dvou komplexních čísel můžeme vyjádřit pomocí roznásobení výrazu:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_times',
		declare_variable(A, 'a', Numbers,
			declare_variable(B, 'b', Numbers,
				declare_variable(C, 'c', Numbers,
					declare_variable(D, 'd', Numbers,
						equal([
							(A + B * imag) * (C + D * imag),
							A * C + A * D * imag + B * C * imag + B * D * imag^2,
							linebreak,
							par(A * C - B * D) + (A * D  + B * C) * imag
						])
					)
				)
			)
		)
	).
\end{prolog}
\eeq{complex_times}

Ke každému komplexnímu číslu \(a + b \cdot \imag\) můžeme zavést komplexně sdružené číslo \(a - b \cdot \imag\). Povšimněme si, že jejich součin daný vztahem~\eqref{eq:complex_multiply_by_conjugate} je reálný.

\begin{prolog}
?-	make_test_real_pairs(Numbers),
	print_validated_formula(
		'complex_multiply_by_conjugate',
		declare_variable([A, B], ['a', 'b'], Numbers,
			equal(
				(A + B * imag) * (A - B * imag),
				A^2 + B^2
			)
		)
	).
\end{prolog}
\eeq{complex_multiply_by_conjugate}

Toho můžeme využít pro vyjádření podílu dvou komplexních čísel:

\begin{prolog}
?-	make_test_real_pairs(Pairs),
	make_test_nonzero_real_pairs(NonzeroPairs),
	print_validated_formula(
		'complex_fraction',
		declare_variable([A, B], ['a', 'b'], Pairs,
			declare_variable([C, D], ['c', 'd'], NonzeroPairs,
				equal([
					(A + B * imag) / (C + D * imag),
					((A + B * imag) * (C - D * imag)) / ((C + D * imag) * (C - D * imag)),
					linebreak,
					(A * C + B * D + B * C * imag - A * D * imag) / (C^2 + D^2),
					(A * C + B * D) / (C^2 + D^2) + (B * C - A * D) / (C^2 + D^2) * imag
				])
			)
		)
	).
\end{prolog}
\eeq{complex_fraction}

\section{Funkce sinus a~kosinus}
