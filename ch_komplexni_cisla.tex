\chapter{Komplexní čísla}


\begin{prolog}
:- ensure_loaded("../equations/formula").
:- ensure_loaded("../equations/truth_table").
:- ensure_loaded("../equations/draw_1d_function").

make_test_numbers([-1, 0, 0.5, 1, 2, 3, 1.5, complex(0, 1), complex(0, -1), complex(1, 1)]).
make_test_real_numbers([-2, -1, 0, 1, 1.5, 2]).
make_test_nonnegative_real_numbers([0, 1, 1.5, 2]).
make_test_real_nonzero_numbers([-2, -1, 1, 1.5, 2]).
make_test_complex_functions(Z, [Z + 2, Z - imag, (1 - imag) * Z, Z^2]).
make_test_real_binary_functions(X, Y, [X + Y, X * Y, X^2 * Y, Y^2 * X]).

make_test_harmonic_functions(
	UX, UY, VX, VY,
	[
		[UX^2 - UY^2, 2 * VX * VY],
		[UX^3 - 3 * UX * UY^2, 3 * VX^2 * VY - VY^3]
	]
).
\end{prolog}

\section{Zavedení komplexních čísel}

V~sekci \ref{sec:realna_cisla} věnované reálným číslům jsme větou~\eqref{eq:sqrt_def} definovali odmocninu kladných čísel. Důvodem tohoto omezení je fakt, že v oboru reálných čísel neexistují sudé odmocniny ze záporných čísel. Například rovnice \(x^2 = -1\) nemá v~oboru reálných čísel řešení, neexistuje proto \(\sqrt{-1}\). Abychom mohli takovéto rovnice řešit, tak rovnicí~\eqref{eq:imag_def} zavedeme imaginární jednotku \(\imag\).

\begin{fact}
\begin{prolog}
?-	print_validated_formula(
		'imag_def',
		equal(imag^2, -1)
	).
\end{prolog}
\eeq{imag_def}
\end{fact}

Uvažujme dvě reálná čísla \(a\) a~\(b\), z~nichž alespoň jedno je nenulové. Chtějme nalézt takovou kombinaci těchto čísel, aby platilo:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_units_ortogonality',
		declare([variable(A, 'a', Numbers), variable(B, 'b', Numbers)],
			proof([
				equal(A * 1 + B * imag, 0)
			],
			[
				equal(A * 1, -B * imag),
				equal(A^2 * 1^2, B^2 * imag^2),
				equal(A^2, -B^2),
				equal(A^2 + B^2, 0)
			])
		)
	).
\end{prolog}
\eeq{complex_units_ortogonality}

Vidíme, že pro nenulová čísla tato rovnice nemůže být splněna. Reálná jednotka \(1\) a~imaginární jednotka \(\imag\) jsou proto navzájem ortogonální - jednu není možné vyjádřit pomocí druhé. Tyto jednotky si tedy můžeme představit jako vzájemně kolmé jednotkové osy ve dvojrozměrném prostoru. Každý bod v~tomto prostoru můžeme popsat jako lineární kombinaci těchto jednotek. Proto tuto lineární kombinaci \(a + b \cdot \imag\) nazveme komplexním číslem zapsaným v~algebraickém tvaru. Množinu všech komplexních čísel označíme \(\complex\).

\begin{fact}
\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_def',
		forall_in([A, B], ['a', 'b'], real_numbers, Numbers,
			in(A + B * imag, complex_numbers)
		)
	).
\end{prolog}
\eeq{complex_def}
\end{fact}

Vyjádřeme operace s~komplexními čísly. Využijeme přitom faktu, že se složkami můžeme provádět algebraické operace. Začněme součtem a~rozdílem komplexních čísel. Ten provádíme po složkách:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_add',
		declare([
			plus_minus(PM), variable(A, 'a', Numbers), variable(B, 'b', Numbers),
			variable(C, 'c', Numbers), variable(D, 'd', Numbers)
		],
			equal(
				plus_minus(par(A + B * imag), par(C + D * imag), PM),
				par(plus_minus(A, C, PM)) + par(plus_minus(B, D, PM)) * imag
			)
		)
	).
\end{prolog}
\eeq{complex_add}

Součin dvou komplexních čísel můžeme vyjádřit pomocí roznásobení výrazu:

\begin{prolog}
?-	make_test_numbers(Numbers),
	print_validated_formula(
		'complex_times',
		declare([variable(A, 'a', Numbers), variable(B, 'b', Numbers), variable(C, 'c', Numbers), variable(D, 'd', Numbers)],
			equal([
				(A + B * imag) * (C + D * imag),
				A * C + A * D * imag + B * C * imag + B * D * imag^2,
				linebreak,
				par(A * C - B * D) + (A * D  + B * C) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_times}

Ke každému komplexnímu číslu \(a + b \cdot \imag\) můžeme zavést komplexně sdružené číslo \(a - b \cdot \imag\). Povšimněme si, že jejich součin daný vztahem~\eqref{eq:complex_multiply_by_conjugate} je reálný.

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		'complex_multiply_by_conjugate',
		declare([variable(A, 'a', Numbers), variable(B, 'b', Numbers)],
			equal(
				(A + B * imag) * (A - B * imag),
				A^2 + B^2
			)
		)
	).
\end{prolog}
\eeq{complex_multiply_by_conjugate}

Toho můžeme využít pro vyjádření podílu dvou komplexních čísel:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_real_nonzero_numbers(NonzeroNumbers),
	print_validated_formula(
		'complex_fraction',
		declare([
			variable(A, 'a', Numbers), variable(B, 'b', Numbers),
			variable(C, 'c', NonzeroNumbers), variable(D, 'd', NonzeroNumbers)
		],
			equal([
				(A + B * imag) / (C + D * imag),
				((A + B * imag) * (C - D * imag)) / ((C + D * imag) * (C - D * imag)),
				linebreak,
				(A * C + B * D + B * C * imag - A * D * imag) / (C^2 + D^2),
				(A * C + B * D) / (C^2 + D^2) + (B * C - A * D) / (C^2 + D^2) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_fraction}

Absolutní hodnota komplexního čísla \(x + Y \cdot \imag\) je dána výrazem \eqref{eq:complex_abs}. Jeho srovnáním se vztahem \eqref{eq:euklidovsky_prostor_metrika} dospějeme k~závěru, že komplexní rovina odpovídá dvojrozměrnému Euklidovskému prostoru.

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		'complex_abs',
		declare([variable(X, 'x', Numbers), variable(Y, 'y', Numbers)],
			equal(abs(X + Y * imag), sqrt(X^2 + Y^2))
		)
	).
\end{prolog}
\eeq{complex_abs}

\section{Komplexní funkce, limita, derivace}

Mějme komplexní funkci komplexní proměnné \(z\):

\begin{equation}
w = \func{f}(z); z, w \in \complex
\end{equation}

Tuto funkci můžeme rozepsat na dvě reálné funkce dvou reálných proměnných:

\begin{equation}
\func{f}(x + y \cdot \imag) = \func{u}(x, y) + \func{v}(x, y) \cdot \imag
\end{equation}

Limitu komplexní funkce definujeme jako limitu funkce dvou parametrů. Znamená to tedy, že funkční hodnota se limitě musí blížit \uv{ze všech směrů}.

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_complex_functions(P, Functions),
	print_validated_formula(
		'complex_lim',
		declare([variable(X0, 'x_0', Numbers), variable(Y0, 'y_0', Numbers), function(F, '\\func{f}', Functions)],
			equal(
				lim(Z, 'z', complex, X0 + Y0 * imag, apply(F, [P], [Z])),
				lim([X, Y], ['x', 'y'], [real, real], [X0, Y0], apply(F, [P], [X + Y * imag]))
			)
		)
	).
\end{prolog}
\eeq{complex_lim}

Derivaci komplexní funkce definujeme obdobně jako derivaci reálné funkce pomocí vztahu~\eqref{eq:complex_derivative}.

\begin{prolog}
?-	make_test_numbers(Numbers),
	make_test_complex_functions(P, Functions),
	print_validated_formula(
		"complex_derivative",
		declare([function(F, "\\func{f}", Functions), variable(Z, 'z', Numbers)],
			equal(
				derivative(Z, apply(F, [P], [Z])),
				lim(DZ, "\\mathrm{d}z", complex, 0, (apply(F, [P], [Z + DZ]) - apply(F, [P], [Z])) / DZ)
			)
		)
	).
\end{prolog}
\eeq{complex_derivative}

Zabývejme se otázkou, kdy tato derivace existuje. Nejdříve rozepišme definici derivace~\eqref{eq:complex_derivative} na podíl diferenciálů. Zavedeme tedy označení \(\func{f}(z + \mathrm{d}z) - \func{f}(z) = \mathrm{d}u + \mathrm{d}v \cdot \imag\) a~\(\mathrm{d}z = \mathrm{d}x + \mathrm{d}y \cdot \imag\):

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_1",
		declare([
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU + DV * imag) / (DX + DY * imag)
				),
				lim([DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					((DU + DV * imag) / (DX + DY * imag)) * ((DX - DY * imag) / (DX - DY * imag))	
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU * DX + DV * DY + (DV * DX - DU * DY) * imag) / (DX^2 + DY^2)
				)
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_1}

Uvědomme si, že limita~\eqref{eq:complex_derivative_conditions_1} je definována pro dvojici proměnných~\(\mathrm{d}x\) a~\(\mathrm{d}y\). Proto můžeme zvolit \(\mathrm{d}x = 0\) a~limita se tím nezmění:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_2",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU + DV * imag) / (DX + DY * imag)
				),
				declare([substitution(DX, "\\mathrm{d}x", 0)],
					lim(
						DY, "\\mathrm{d}y", real, 0,
						(DV * DY - DU * DY * imag) / DY^2
					)
				),
				linebreak,
				declare([substitution(DX, "\\mathrm{d}x", 0)],
					lim(
						DY, "\\mathrm{d}y", real, 0,
						(DV - DU * imag) / DY
					)
				),
				derivative(Y, apply(V, [VX, VY], [X, Y])) - derivative(Y, apply(U, [UX, UY], [X, Y])) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_2}

Obdobně můžeme zvolit \(\mathrm{d}y = 0\) a~získáme:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_3",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU + DV * imag) / (DX + DY * imag)
				),
				declare([substitution(DY, "\\mathrm{d}y", 0)],
					lim(
						DX, "\\mathrm{d}x", real, 0,
						(DU * DX + DV * DX * imag) / DX^2
					)
				),
				linebreak,
				declare([substitution(DY, "\\mathrm{d}y", 0)],
					lim(
						DX, "\\mathrm{d}x", real, 0,
						(DU + DV * imag) / DX
					)
				),
				derivative(X, apply(U, [UX, UY], [X, Y])) + derivative(X, apply(V, [VX, VY], [X, Y])) * imag
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_3}

Srovnejme vztahy~\eqref{eq:complex_derivative_conditions_2} a~\eqref{eq:complex_derivative_conditions_3}. Dvě komplexní čísla jsou shodná, pokud mají stejnou reálnou i~imaginární složku. Proto má-li komplexní funkce derivaci, tak bude platit:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_4",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions),
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers)
		],
			and(
				equal(derivative(X, apply(U, [UX, UY], [X, Y])), derivative(Y, apply(V, [VX, VY], [X, Y]))),
				equal(derivative(Y, apply(U, [UX, UY], [X, Y])), -derivative(X, apply(V, [VX, VY], [X, Y])))
			)
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_4}

Podmínky~\eqref{eq:complex_derivative_conditions_4} se nazývají Cauchyovy-Riemannovy podmínky. 
Má-li komplexní funkce derivaci v~každém bodě určité oblasti, pak říkáme, že je v~této oblasti analytická.

Zabývejme se otázkou, zda je splnění podmínek~\eqref{eq:complex_derivative_conditions_4} postačující k~existenci derivace komplexní funkce. Ve vztazích~\eqref{eq:complex_derivative_conditions_2} a~\eqref{eq:complex_derivative_conditions_3} jsme položili \(\mathrm{d}x = 0\) respektive \(\mathrm{d}y = 0\), uvažovali jsme tedy pouze okolní body se stejnou reálnou respektive imaginární složkou. Potřebujeme ale ověřit, že všechny okolní body se blíží k~limitě~\eqref{eq:complex_derivative_conditions_1}. Pokračujme proto upravováním vztahu
~\eqref{eq:complex_derivative_conditions_1}

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_harmonic_functions(UX, UY, VX, VY, Functions),
	print_validated_formula(
		"complex_derivative_conditions_5",
		declare([
			function([U, V], ["\\func{u}", "\\func{v}"], Functions), 
			variable(X, "x", Numbers),
			variable(Y, "y", Numbers),
			substitution(DU, "\\mathrm{d}u", apply(U, [UX, UY], [X + DX, Y + DY]) - apply(U, [UX, UY], [X, Y])),
			substitution(DV, "\\mathrm{d}v", apply(V, [VX, VY], [X + DX, Y + DY]) - apply(V, [VX, VY], [X, Y]))
		],
			equal([
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(DU * DX + DV * DY + (DV * DX - DU * DY) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					((DU / DX) * DX^2 + (DV / DY) * DY^2 + ((DV / DX) * DX^2 - (DU / DY) * DY^2) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(derivative(X, apply(U, [UX, UY], [X, Y])) * DX^2 + derivative(Y, apply(V, [VX, VY], [X, Y])) * DY^2 + (derivative(X, apply(V, [VX, VY], [X, Y])) * DX^2 - derivative(Y, apply(U, [UX, UY], [X, Y])) * DY^2) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(derivative(X, apply(U, [UX, UY], [X, Y])) * DX^2 + derivative(X, apply(U, [UX, UY], [X, Y])) * DY^2 + (derivative(X, apply(V, [VX, VY], [X, Y])) * DX^2 + derivative(X, apply(V, [VX, VY], [X, Y])) * DY^2) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					(derivative(X, apply(U, [UX, UY], [X, Y])) * (DX^2 + DY^2) + (derivative(X, apply(V, [VX, VY], [X, Y])) * (DX^2 + DY^2)) * imag) / (DX^2 + DY^2)
				),
				linebreak,
				lim(
					[DX, DY], ["\\mathrm{d}x", "\\mathrm{d}y"], [real, real], [0, 0],
					derivative(X, apply(U, [UX, UY], [X, Y])) + derivative(X, apply(V, [VX, VY], [X, Y])) * imag
				)
			])
		)
	).
\end{prolog}
\eeq{complex_derivative_conditions_5}

Vidíme, že podmínky~\eqref{eq:complex_derivative_conditions_4} jsou podmínky nutné i~postačující.

\section{Funkce sinus a~kosinus, Eulerův vzorec}

Úhel sevřený dvěma polopřímkami se společným bodem v~obloukové míře je udáván délkou oblouku, které tyto dvě polopřímky vytknou na jednotkové kruřnici. Udává se v~radiánech. Plný úhel má proto velikost \(2 \pi \ \rad\), přímý úhel \(\pi \ \rad\) a~pravý úhel \(\frac{\pi}{2} \ \rad\).

\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}

\pgfmathsetmacro{\ang}{45}
\pgfmathsetmacro{\r}{4}
\pgfmathsetmacro{\p}{5}
\pgfmathsetmacro{\x}{cos(\ang)}
\pgfmathsetmacro{\y}{sin(\ang)}

\draw (0, 0) -- (\r, 0);
\draw[dashed] (\r, 0) -- (\p, 0);
\draw (\r / 2, 0) node[anchor=north]{1};

\draw (0, 0) -- (\r * \x, \r * \y);
\draw[dashed] (\r * \x, \r * \y) -- (\p * \x, \p * \y);
\draw (\r / 2 * \x, \r / 2 * \y) node[anchor=south east]{1};

\draw[->] (\r, 0) arc(0:\ang:\r);
\draw (\r * 0.92388, \r * 0.38268) node[anchor=west]{\(\alpha\)};
\end{tikzpicture}
\caption{Oblouková míra úhlu}
\label{img:rad_def}
\end{center}
\end{figure}

Mějme kartézský souřadný systém v~rovině, jak je zobrazeno na obrázku~\ref{img:sin_cos_def}. Dále mějme úsečku s~počátečním bodem v~počátku souřadného systému délkou 1. Tato úsečka bude svírat s~osou \(x\) orientovaný úhel \(\alpha\). Potom koncový bod této úsečky bude mít souřadnice \([x, y] = [\cos \alpha, \sin \alpha]\). Pokud by úsečka měla obecně délku \(r\), pak bz souřadnice bodu byly proporcionálně větší, tedy \([x, y] = [r \cdot \cos \alpha, r \cdot \sin \alpha]\). Funkce jsou zobrazeny na obrázcích~\ref{img:sin_function} a~\ref{img:cos_function}.

\begin{prolog}
?-	draw_1d_function(
		'sin_function',
		X,
		'x',
		sin(X),
		-2*pi, +2*pi
	).				
\end{prolog}
\eimg{sin_function}{Graf funkce sinus}

\begin{prolog}
?-	draw_1d_function(
		'cos_function',
		X,
		'x',
		cos(X),
		-2*pi, +2*pi
	).				
\end{prolog}
\eimg{cos_function}{Graf funkce kosinus}

\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}

\pgfmathsetmacro{\r}{2.5}
\pgfmathsetmacro{\axr}{1.2 * \r}

\pgfmathsetmacro{\ang}{30}
\pgfmathsetmacro{\x}{cos(\ang)}
\pgfmathsetmacro{\y}{sin(\ang)}

\drawaxesxy{0}{0}{-\axr}{-\axr}{+\axr}{+\axr};
\draw (0, 0) circle[radius=\r];

\draw[->] (0, 0) -- (\r * \x, \r * \y);

\draw[dashed] (0, \r * \y) -- (\r * \x, \r * \y) -- (\r * \x, 0);

\draw (\r * \x / 2, 0) node[anchor=north]{\(\cos \alpha\)};
\draw (0, \r * \y / 2) node[anchor=east]{\(\sin \alpha\)};
\draw (\r / 2 * \x, \r / 2 * \y) node[anchor=south]{1};

\draw[->] (1, 0) arc(0:\ang:1);
\draw (0.96593, 0.2) node[anchor=east]{\(\alpha\)};

\drawrightangle{\r * \x}{0}{0.3}{90};
\drawrightangle{0}{\r * \y}{0.3}{270};
\end{tikzpicture}
\caption{Definice sinu a~kosinu}
\label{img:sin_cos_def}
\end{center}
\end{figure}


Odvoďme nyní derivaci funkcí sinus a~kosinus. Mějme opět jednotkovou úsečku OA s~jedním koncem v~počátku soustavy souřadnic, jak je zobrazeno na obrázku \eqref{img:sin_cos_derivative}. Tato úsečka svírá s~osou \(x\) orientovaný úhel \(\alpha\) a~její koncový bod A má tedy souřadnice \([\cos \alpha, \sin \alpha]\). Mějme další úsečku OB, která svírá s~osou \(x\) úhel o~\(\mathrm{d}\alpha\) větší. Její koncový bod B má tedy souřadnice \([\cos (\alpha + \mathrm{d}\alpha), \sin (\alpha + \mathrm{d}\alpha)]\). Oblouk kružnice mezi body A a~B má podle definice obloukové míry délku~\(\mathrm{d}\alpha\). Pro \(\mathrm{d}\alpha \to 0\) tento oblouk přechází v~úsečku. Proto pro \(\mathrm{d}\alpha\) je délka sečny \(|AB| = \mathrm{d}\alpha\). Dále si uvědomme, že pro \(\mathrm{d}\alpha \to 0\) sečna AB přechází v~tečnu a~je proto kolmá na úsečku OA, která je poloměrem kružnice. Díky tomu úsečka BA svírá s~(opačnou) osou y úhel \(\alpha\). Proto v~bodě B můžeme zavést lokální souřadný systém s~osou x mířící směrem dolů a~odvodit:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"sin_derivative_proof",
		declare([
			variable(A, "\\alpha", Numbers) 
		],
			proof([],
			[
				declare(
					[substitution(DA, "\\mathrm{d}\\alpha", 1e-8)],
					equal(sin(A + DA) - sin(A), DA * cos(A))
				),
				equal(lim(DA, "\\mathrm{d}\\alpha", real, 0, (sin(A + DA) - sin(A)) / DA), cos(A)),
				equal(derivative(A, sin(A)), cos(A))
			])
		)
	).
\end{prolog}
\eeq{sin_derivative_proof}

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"cos_derivative_proof",
		declare([
			variable(A, "\\alpha", Numbers) 
		],
			proof([],
			[
				declare(
					[substitution(DA, "\\mathrm{d}\\alpha", 1e-8)],
					equal(cos(A + DA) - cos(A), -(DA * sin(A)))
				),
				equal(lim(DA, "\\mathrm{d}\\alpha", real, 0, (cos(A + DA) - cos(A)) / DA), -sin(A)),
				equal(derivative(A, cos(A)), -sin(A))
			])
		)
	).
\end{prolog}
\eeq{cos_derivative_proof}

\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}
\pgfmathsetmacro{\r}{10}
\pgfmathsetmacro{\axr}{1.2 * \r}

\pgfmathsetmacro{\ang}{30}
\pgfmathsetmacro{\x}{cos(\ang)}
\pgfmathsetmacro{\y}{sin(\ang)}

\pgfmathsetmacro{\angb}{40}
\pgfmathsetmacro{\xb}{cos(\angb)}
\pgfmathsetmacro{\yb}{sin(\angb)}

\pgfmathsetmacro{\angd}{atan((\xb - \x) / (\y - \yb))}

\draw (0, 0) node[anchor=north east]{O};
\draw[->] (0, 0) -- (\r * \x, \r * \y) node[anchor=south west]{A};
\draw[dashed] (0, \r * \y) -- (\r * \x, \r * \y) -- (\r * \x, 0);

\draw (\r * \x, 0) node[anchor=north]{\(\cos \alpha\)};
\draw (\r * \xb, 0) node[anchor=north east]{\(\cos(\alpha + \mathrm{d}\alpha)\)};

\draw (0, \r * \y) node[anchor=east]{\(\sin \alpha\)};
\draw (0, \r * \yb) node[anchor=east]{\(\sin(\alpha + \mathrm{d}\alpha)\)};

\draw (\r / 2 * \x, \r / 2 * \y) node[anchor=north]{1};

\draw[->] (0, 0) -- (\r * \xb, \r * \yb) node[anchor=south west]{B};

\draw (\r * \xb, \r * \yb) -- (\r * \x, \r * \y);
\draw[dashed] (0, \r * \yb) -- (\r * \xb, \r * \yb) -- (\r * \xb, 0);

\draw(\r, 0) arc(-0:90:\r);
\drawaxesxy{0}{0}{-0.5}{-0.5}{+\axr}{+\axr};

\draw[->] (1, 0) arc(0:\ang:1);
\draw (0.96593, 0.2) node[anchor=east]{\(\alpha\)};
\draw (\r * \xb, \r * \yb - 0.5) node[anchor=north west]{\(\alpha\)};

\drawsmallangle{0}{0}{1.5}{\ang}{\angb}{\(\mathrm{d}\alpha\)};
\drawrightangle{\r * \xb}{\r * \y}{0.3}{0};

\draw (\r * \x / 2 + \r * \xb / 2, \r * \y / 2 + \r * \yb / 2) node[anchor=west]{\(\mathrm{d}\alpha\)};

\draw[->] (\r * \xb - 1.8, 2) -- (\r * \xb, 2);
\draw (\r * \xb, 2) -- (\r * \x, 2);
\draw[<-] (\r * \x, 2) -- (\r * \x + 0.3, 2);
\draw (\r * \xb - 0.2, 2) node[anchor=south east]{\(\mathrm{d}\alpha \cdot \cos \alpha\)};

\draw[<->] (2, \r * \yb) -- (2, \r * \y);
\draw (2, \r * \yb / 2 + \r * \y / 2) node[anchor=west]{\(\mathrm{d}\alpha \cdot \sin \alpha\)};

\draw[->] (\r * \xb, \r * \yb - 1) arc(270:270+\angd:1);

\drawrightangle{\r * \x}{0}{0.3}{90};
\drawrightangle{\r * \xb}{0}{0.3}{90};
\drawrightangle{0}{\r * \y}{0.3}{270};
\drawrightangle{0}{\r * \yb}{0.3}{270};
\end{tikzpicture}
\caption{Derivace funkcí sinus a~kosinus}
\label{img:sin_cos_derivative}
\end{center}
\end{figure}

Zabývejme se dále exponenciální funkcí \(e^{x \cdot \imag}\). Její derivace je

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"exp_sin_cos_proof_1",
		declare([
			variable(X, "x", Numbers),
			substitution(U, "\\mathrm{u}", cos(UX)),
			substitution(V, "\\mathrm{v}", sin(VX)) 
		],
			proof([],
			[
				equal(e^(X * imag), apply(U, [UX], [X]) + apply(V, [VX], [X]) * imag),
				equal(derivative(X, e^(X * imag)), e^(X * imag) * imag),
				equal(
					derivative(X, apply(U, [UX], [X]) + apply(V, [VX], [X]) * imag),
					(apply(U, [UX], [X]) + apply(V, [VX], [X]) * imag) * imag
				),
				equal(
					derivative(X, apply(U, [UX], [X])) + derivative(X, apply(V, [VX], [X])) * imag,
					-apply(V, [VX], [X]) + apply(U, [UX], [X]) * imag
				),
				and(
					equal(derivative(X, apply(U, [UX], [X])), -apply(V, [VX], [X])),
					equal(derivative(X, apply(V, [VX], [X])), apply(U, [UX], [X]))
				)
			])
		)
	).
\end{prolog}
\eeq{exp_sin_cos_proof_1}

Obdobně můžeme odvodit hodnoty funkcí pro \(x = 0\):


\begin{prolog}
?-	print_validated_formula(
		"exp_sin_cos_proof_2",
		declare([
			substitution(U, "\\mathrm{u}", cos(UX)),
			substitution(V, "\\mathrm{v}", sin(VX)) 
		],
			proof([],
			[
				equal(e^(0 * imag), 1),
				equal(
					apply(U, [UX], [0]) + apply(V, [VX], [0]) * imag,
					1 + 0 * imag
				),
				and(
					equal(apply(U, [UX], [0]), 1),
					equal(apply(V, [VX], [0]), 0)
				)
			])
		)
	).
\end{prolog}
\eeq{exp_sin_cos_proof_2}

Už víme, že platí

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"exp_sin_cos_proof_3",
		declare([
			variable(X, "x", Numbers)
		],
			and(
				equal(derivative(X, cos(X)), -sin(X)),
				equal(derivative(X, sin(X)), cos(X))
			)
		)
	).
\end{prolog}
\eeq{exp_sin_cos_proof_3}


a~z~obrázku~\ref{img:sin_cos_def} jsou také vidět hodnoty: 

\begin{prolog}
?-	print_validated_formula(
		"exp_sin_cos_proof_4",
			and(
				equal(cos(0), 1),
				equal(sin(0), 0)
		)
	).
\end{prolog}
\eeq{exp_sin_cos_proof_4}

Jak vztahy~\eqref{eq:exp_sin_cos_proof_1} a~\eqref{eq:exp_sin_cos_proof_2}, tak i~vztahy~\eqref{eq:exp_sin_cos_proof_3} a~\eqref{eq:exp_sin_cos_proof_4} představují sosutavy dvou obyčejných diferenciálních rovnic prvního řádu.
Protože hodnoty v~počátku i~průběh prvních derivací jsou si rovny, tak platí

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"exp_sin_cos_proof_result",
		declare([
			variable(X, "x", Numbers),
			substitution(U, "\\mathrm{u}", cos(UX)),
			substitution(V, "\\mathrm{v}", sin(VX)) 
		],
			proof([],
			[
				and(
					equal(apply(U, [UX], [X]), cos(X)),
					equal(apply(V, [VX], [X]), sin(X))
				),
				equal(e^(X * imag), cos(X) + imag * sin(X))
			])
		)
	).
\end{prolog}
\eeq{exp_sin_cos_proof_result}

To je známý Eulerův vzorec udávající vztah mezi exponenciální funkcí komplexního čísla a~goniometrickými funkcemi.

Eulerův vzorec můžeme využít pro odvození některých goniometrických identit. Například odvodíme vztah pro sinus a~kosinus součtu úhlů:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"cos_sin_a_plus_b",
		declare([
			variable(A, "\\alpha", Numbers),
			variable(B, "\\beta", Numbers)
		],
			equal([
				cos(A + B) + imag * sin(A + B),
				e^(imag * (A + B)),
				e^(imag * A) * e^(imag * B),
				linebreak,
				(cos(A) + imag * sin(A)) * (cos(B) + imag * sin(B)),
				linebreak,
				cos(A) * cos(B) - sin(A) * sin(B) + imag * (cos(A) * sin(B) + sin(A) * cos(B))
			])
		)
	).
\end{prolog}
\eeq{cos_sin_a_plus_b}

Dvě komplexní čísla jsou shodná, pokud mají stejnou reálnou i~imaginární složku. Proto

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"cos_a_plus_b",
		declare([
			variable(A, "\\alpha", Numbers),
			variable(B, "\\beta", Numbers)
		],
			equal(cos(A + B), cos(A) * cos(B) - sin(A) * sin(B))
		)
	).
\end{prolog}
\eeq{cos_a_plus_b}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"sin_a_plus_b",
		declare([
			variable(A, "\\alpha", Numbers),
			variable(B, "\\beta", Numbers)
		],
			equal(sin(A + B), cos(A) * sin(B) + sin(A) * cos(B))
		)
	).
\end{prolog}
\eeq{sin_a_plus_b}

Substitucí \(\beta \leftarrow -\beta\) a~využitím faktu, že sinus je lichá funkce a~kosinus sudá, získáme:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"cos_a_minus_b",
		declare([
			variable(A, "\\alpha", Numbers),
			variable(B, "\\beta", Numbers)
		],
			equal(cos(A - B), cos(A) * cos(B) + sin(A) * sin(B))
		)
	).
\end{prolog}
\eeq{cos_a_minus_b}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"sin_a_minus_b",
		declare([
			variable(A, "\\alpha", Numbers),
			variable(B, "\\beta", Numbers)
		],
			equal(sin(A - B), sin(A) * cos(B) - cos(A) * sin(B))
		)
	).
\end{prolog}
\eeq{sin_a_minus_b}

a~obdobně substitucí \(\beta \leftarrow \alpha\) získáme:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"cos_2a",
		declare([
			variable(A, "\\alpha", Numbers)
		],
			equal(cos(2*A), (cos(A))^2 - (sin(A))^2)
		)
	).
\end{prolog}
\eeq{cos_2a}
%%%%%%%%%%%%%%%%%%%%
\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"sin_2a",
		declare([
			variable(A, "\\alpha", Numbers)
		],
			equal(sin(2 * A), 2 * cos(A) * sin(A))
		)
	).
\end{prolog}
\eeq{sin_2a}

\section{Tvary komplexních čísel}

Komplexní čísla lze zapsat v~různých tvarech. Jeden z~nich - algebraický tvar - už známe:

\begin{equation}
z = x + y * \imag
\end{equation}

Komplexní čísla si můžeme představit jako body v~komplexní (Gaussově) rovině, jak je vidět na obrázku~\ref{img:complex_plane}.

\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}

\pgfmathsetmacro{\x}{4}
\pgfmathsetmacro{\y}{3}
\pgfmathsetmacro{\ang}{atan(\y / \x)}

\drawaxex{0}{0}{-0.5}{4.5}{0}{4}{x};
\drawaxey{0}{0}{-0.5}{3.5}{0}{3}{y};

\draw[->] (0, 0) -- (\x, \y);
\draw[dashed] (0, \y) -- (\x, \y) -- (\x, 0);

\draw[->] (1.5, 0) arc(0:\ang:1.5);

\draw (1, 0.4) node{\(\varphi\)};
\draw (\x / 2, \y / 2) node[anchor=south]{\(r\)};
\end{tikzpicture}
\caption{Zobrazení čísla \(z = 4 + 3 \cdot i\) v~komplexní rovině}
\label{img:complex_plane}
\end{center}
\end{figure}

Totéž číslo můžeme také zapsat v~tzv. goniometrickém tvaru

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_nonnegative_real_numbers(NonnegativeNumbers),
	print_validated_formula(
		"complex_goniometric",
		declare([
			variable(R, "r", NonnegativeNumbers),
			variable(Phi, "\\varphi", Numbers),
			substitution(X, "x", R * cos(Phi)),
			substitution(Y, "y", R * sin(Phi)),
			substitution(Z, "z", X + Y * imag)
		],
			equal([
				Z,
				X + Y * imag,
				R * cos(Phi) + imag * R * sin(Phi),
				linebreak,
				abs(Z) * cos(arg(Z)) + imag * abs(Z) * sin(arg(Z))
			])
		)
	).
\end{prolog}
\eeq{complex_goniometric}

přičemž \(\alpha = \arg z\) je tzv. argument komplexního čísla. Lze jej spočítat jako \(\arctg \frac{y}{x}\), který je ale definován ve všech čtyřech kvadrantech. V~běžných programovacích jazycích jej implementuje funkce atan2.

Goniometrický tvar můžeme zapsat kompaktněji v~exponenciálním tvaru. Využíváme při tom Eulerův vzorec~\eqref{eq:exp_sin_cos_proof_result}.


\begin{prolog}
?-	make_test_real_numbers(Numbers),
	make_test_nonnegative_real_numbers(NonnegativeNumbers),
	print_validated_formula(
		"complex_exponential",
		declare([
			variable(R, "r", NonnegativeNumbers),
			variable(Phi, "\\varphi", Numbers),
			substitution(X, "x", R * cos(Phi)),
			substitution(Y, "y", R * sin(Phi)),
			substitution(Z, "z", X + Y * imag)
		],
			equal([
				Z,
				R * cos(Phi) + imag * R * sin(Phi),
				linebreak,
				R * e^(Phi * imag),
				abs(Z) * e^(arg(Z) * imag)
			])
		)
	).
\end{prolog}
\eeq{complex_exponential}

\section{Využití komplexních čísel pro reprezentaci harmonických funkcí}

Mějme obecnou harmonickou funkci ve tvaru \(\func{f}(t) = A \cdot \sin(\omega \cdot t + \varphi)\). Představuje-li tato funkce časový průběh nějakého děje, pak \(A\) je amplituda, \(\omega\) je úhlový kmitočet, \(t\) je čas a~\(\varphi\) je fázový posun. Podle Eulerova vzorce~\eqref{eq:exp_sin_cos_proof_result} platí:

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"harmonic_as_complex",
		declare([
			variable(A, "A", Numbers),
			variable(Omega, "\\omega", Numbers),
			variable(Phi, "\\varphi", Numbers),
			variable(T, "t", Numbers),
			substitution(Z, "z", A * e^(imag * Phi))
		],
			equal([
				A * sin(Omega * T + Phi),
				imag_part(A * e^(imag * (Omega * T + Phi))),
				linebreak,
				imag_part(A * e^(imag * Phi) * e^(imag * Omega * T)),
				imag_part(Z * e^(imag * Omega * T))
			])
		)
	).
\end{prolog}
\eeq{harmonic_as_complex}

Každou harmonickou funkci proto můžeme zapsat jako imaginární složku součinu komplexního čísla \(z\) a~členu \(e^{\imag \cdot \omega \cdot t}\). V~komplexním čísle \(z\) je obsažena jak amplituda \(A\) tak i~fázový posun \(\varphi\). Proto pro daný úhlový kmitočet \(\omega\) komplexní číslo \(z\) plně reprezentuje harmonickou funkci~\eqref{eq:harmonic_as_complex}, říkáme, že je jeho obrazem. Namísto počítání s~harmonickými funkcemi proto můžeme počítat s~jejich obrazy - komplexními čísly - a~velmi si tak výpočty zjednodušit. 

Především si všimněme, že zobrazení harmonické funkce na její obraz je lineární. Proto platí:


\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"harmonic_sum",
		declare([
			plus_minus(PM),
			variable(A, "A", Numbers),
			variable(B, "B", Numbers),
			variable(Omega, "\\omega", Numbers),
			variable(Phi, "\\varphi", Numbers),
			variable(Psi, "\\psi", Numbers),
			variable(T, "t", Numbers),
			substitution(ZA, "z_a", A * e^(imag * Phi)),
			substitution(ZB, "z_b", B * e^(imag * Psi)),
			substitution(ZY, "z_y", plus_minus(ZA, ZB, PM))
		],
			proof([],
			[
				equal([
					plus_minus(A * sin(Omega * T + Phi), B * sin(Omega * T + Psi), PM),
					linebreak,
					plus_minus(imag_part(A * e^(imag * Phi) * e^(imag * Omega * T)), imag_part(B * e^(imag * Psi) * e^(imag * Omega * T)), PM),
					linebreak,
					imag_part(plus_minus(A * e^(imag * Phi), B * e^(imag * Psi), PM) * e^(imag * Omega * T))
				]),
				equal(
					imag_part(ZY * e^(imag * Omega * T)),
					plus_minus(imag_part(ZA * e^(imag * Omega * T)), imag_part(ZB * e^(imag * Omega * T)), PM)
				),
				equal(
					ZY,
					plus_minus(ZA, ZB, PM)
				)
			])
				
		)
	).
\end{prolog}
\eeq{harmonic_sum}

\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"harmonic_multiply",
		declare([
			variable(K, "k", Numbers),
			variable(A, "A", Numbers),
			variable(Omega, "\\omega", Numbers),
			variable(Phi, "\\varphi", Numbers),
			variable(T, "t", Numbers),
			substitution(ZA, "z_a", A * e^(imag * Phi)),
			substitution(ZY, "z_y", K * ZA)
		],
			proof([],
			[
				equal([
					K * A * sin(Omega * T + Phi),
					linebreak,
					K * imag_part(A * e^(imag * Phi) * e^(imag * Omega * T)),
					linebreak,
					imag_part(K * A * e^(imag * Phi) * e^(imag * Omega * T))
				]),
				equal(
					imag_part(ZY * e^(imag * Omega * T)),
					K * imag_part(ZA * e^(imag * Omega * T))
				),
				equal(
					ZY,
					K * ZA
				)
			])
		)
	).
\end{prolog}
\eeq{harmonic_multiply}

Tedy součet a~rozdíl harmonických funkcí odpovídá součtu a~rozdílu jejich obrazů. Násobení harmonické funkce reálným koeficientem odpovídá násobení jejího obrazu tímž koeficientem.


\begin{prolog}
?-	make_test_real_numbers(Numbers),
	print_validated_formula(
		"harmonic_multiply",
		declare([
			variable(A, "A", Numbers),
			variable(Omega, "\\omega", Numbers),
			variable(Phi, "\\varphi", Numbers),
			variable(T, "t", Numbers),
			substitution(ZA, "z_a", A * e^(imag * Phi)),
			substitution(ZY, "z_y", imag * Omega * ZA)
		],
			proof([],
			[
				equal([
					derivative(T, A * sin(Omega * T + Phi)),
					linebreak,
					derivative(T, imag_part(A * e^(imag * Phi) * e^(imag * Omega * T))),
					linebreak,
					imag_part(A * e^(imag * Phi) * imag * Omega * e^(imag * Omega * T))
				]),
				equal(
					imag_part(ZY * e^(imag * Omega * T)),
					imag_part(imag * Omega * ZA * e^(imag * Omega * T))
				),
				equal(
					ZY,
					imag * Omega * ZA
				)
			])
		)
	).
\end{prolog}
\eeq{harmonic_multiply}
